<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>七皇</title>
  <icon>https://www.gravatar.com/avatar/f1ffc9e0a95c344bc9636e7512958903</icon>
  <subtitle>KingstonXZJ</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kingstonxzj.github.io/"/>
  <updated>2020-04-02T12:12:38.221Z</updated>
  <id>https://kingstonxzj.github.io/</id>
  
  <author>
    <name>七皇</name>
    <email>kingstonxzj@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式之单例模式</title>
    <link href="https://kingstonxzj.github.io/2020/04/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://kingstonxzj.github.io/2020/04/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-02T12:07:41.000Z</published>
    <updated>2020-04-02T12:12:38.221Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="设计模式类型"><a href="#设计模式类型" class="headerlink" title="设计模式类型"></a>设计模式类型</h1><p><strong>设计模式分为三种类型，共23种：</strong></p><ol><li><strong>创建型模式：</strong> <strong>单例模式</strong>、抽象工厂模式、原型模式、建造者模式、<strong>工厂模式</strong></li><li><strong>结构型模式：</strong> 适配器模式、桥接模式、<strong>装饰模式</strong>、组合模式、外观模式、享元模式、<strong>代理模式</strong></li><li><strong>行为型模式：</strong> 模板方法模式、命令模式、访问者模式、迭代器模式、<strong>观察者模式</strong>、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式（责任链模式）<h1 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2>所谓类的单例模式，就是采取一定的方法保证在整个软件系统中，对某个类<strong>只能存在一个对象实例</strong> ,并且该类只提供一个取得其对象实例的方法（静态方法）。</li></ol><p>比如SessionFactory，它充当数据存储源的代理，并负责创建Session对象，SessionFactory并不是轻量级的，一般情况下，一个项目通常只需要一个SessionFactory就够，这就使用到了单例模式</p><h2 id="单例模式的八种实现方式："><a href="#单例模式的八种实现方式：" class="headerlink" title="单例模式的八种实现方式："></a>单例模式的八种实现方式：</h2><p>首先我们使用一个测试类，其中创建两个Singleton对象，通过比较这两个对象直接是否相等来判断是否为同一个对象</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>{</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>{</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">        Singleton instance2 = Singleton.getInstance();</span><br><span class="line">        System.out.println(instance == instance2);</span><br><span class="line">        System.out.println(<span class="string">"instance.hashCode="</span> + instance.hashCode() );</span><br><span class="line">        System.out.println(<span class="string">"instance2.hashCode="</span> + instance2.hashCode() ); </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="1-饿汉式（静态常量）"><a href="#1-饿汉式（静态常量）" class="headerlink" title="1.饿汉式（静态常量）"></a>1.饿汉式（静态常量）</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2.本类内部创建对象实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3.提供一个公有的静态方法，返回实例对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>优缺点说明：</strong>  </p><p>1）<strong>优点</strong>：写法简单，在类装载时完成实例化，<strong>避免了线程同步</strong><br>2）<strong>缺点</strong>：<strong>没有达到懒加载</strong> Lazy Loading的效果。如果从始至终没有使用该实例，<strong>可能会造成内存的浪费</strong></p><h3 id="2-饿汉式（静态代码块）"><a href="#2-饿汉式（静态代码块）" class="headerlink" title="2.饿汉式（静态代码块）"></a>2.饿汉式（静态代码块）</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2.本类内部创建对象实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3.提供一个公有的静态方法，返回实例对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>优缺点说明：</strong></p><p>优缺点和饿汉式静态常量一样，只是将类实例化的过程放在了静态代码块中，也是在类装载时执行静态代码块中的代码，初始化类的实例。</p><h3 id="3-懒汉式1（线程不安全）"><a href="#3-懒汉式1（线程不安全）" class="headerlink" title="3.懒汉式1（线程不安全）"></a>3.懒汉式1（线程不安全）</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供一个静态的共有方法，当使用到该方法时才去创建instance</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>优缺点说明：</strong></p><p>1）起到了<strong>懒加载</strong>的效果，但是只能在单线程下使用。<br>2）如果在多线程下，一个线程进入了if (instance == null) 判断语句，还没来得及往下执行，另一个线程也通过了这个判断语句，这时便<strong>会产生多个实例</strong>。所以<strong>在多线程环境下不可使用这种方式</strong></p><h3 id="4-懒汉式2（线程安全，同步方法）"><a href="#4-懒汉式2（线程安全，同步方法）" class="headerlink" title="4.懒汉式2（线程安全，同步方法）"></a>4.懒汉式2（线程安全，同步方法）</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><blockquote><p>关键字<strong>synchronized</strong>可以保证在同一时刻，只有一个线程可以执行某个方法或某个代码块，同时synchronized可以保证一个线程的变化可见（可见性）</p></blockquote><p><strong>优缺点说明：</strong><br>1）解决了线程不安全问题<br>2）效率太低。每个线程想获得实例时，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例直接return就好。</p><h3 id="5-懒汉式3（线程安全，同步代码块）"><a href="#5-懒汉式3（线程安全，同步代码块）" class="headerlink" title="5.懒汉式3（线程安全，同步代码块）"></a>5.懒汉式3（线程安全，同步代码块）</h3><p>这种方式本意是想对懒汉式2的改进，改为同步产生实例化的代码块<br>但是这种同步并不能起到线程同步的作用。跟懒汉式1一样可能会产生多个实例，故在此不做介绍。</p><h3 id="6-双重检查（解决线程安全与效率问题）"><a href="#6-双重检查（解决线程安全与效率问题）" class="headerlink" title="6.双重检查（解决线程安全与效率问题）"></a><strong>6.双重检查（解决线程安全与效率问题）</strong></h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供一个静态的公有方法，加入双重检查代码，解决线程安全问题，同时解决懒加载问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>{</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><blockquote><p>volatile 是一个类型修饰符。volatile的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略。  </p></blockquote><p><strong>优缺点说明：</strong></p><p>1）双重检查概念是多线程开发种常使用到的，如代码中所示，我们<strong>进行了两次if(instance == null)检查</strong>，<strong>实例化代码只用执行一次</strong>，后面再访问是，instance!=null直接return实例化对象，也避免的反复进行方法同步<br>2）<strong>线程安全，延迟加载，效率较高</strong></p><h3 id="7-静态内部类"><a href="#7-静态内部类" class="headerlink" title="7.静态内部类"></a>7.静态内部类</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>{ }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写一个静态内部类，该类中由一个静态属性Singleton</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span></span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>优缺点说明：</strong></p><p>1）采用类装载的机制来保证初始化实例时只有一个线程<br>2）类的静态属性只会在第一次加载类时初始化，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程时无法进入的</p><h3 id="8-枚举"><a href="#8-枚举" class="headerlink" title="8.枚举"></a>8.枚举</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Singleton{</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayOK</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"ok"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;设计模式类型&quot;&gt;&lt;a href=&quot;#设计模式类型&quot; class=&quot;headerlink&quot; title=&quot;设计模式类型&quot;&gt;&lt;/a&gt;设计模式类型&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;设计模式分为三种类型，共23种：&lt;/str
      
    
    </summary>
    
    
      <category term="java基础" scheme="https://kingstonxzj.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="https://kingstonxzj.github.io/tags/java/"/>
    
      <category term="基础" scheme="https://kingstonxzj.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="https://kingstonxzj.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="https://kingstonxzj.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：最小的k个数</title>
    <link href="https://kingstonxzj.github.io/2020/04/02/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/"/>
    <id>https://kingstonxzj.github.io/2020/04/02/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</id>
    <published>2020-04-02T11:03:17.000Z</published>
    <updated>2020-04-02T11:06:57.956Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="面试题40-最小的k个数"><a href="#面试题40-最小的k个数" class="headerlink" title="面试题40. 最小的k个数"></a>面试题40. 最小的k个数</h1><p><strong>难度：简单</strong></p><p>输入整数数组arr，找出其中最小的k个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><p><strong>示例1：</strong> </p><blockquote><p>输入：arr = [3,2,1], k = 2<br>输出：[1,2] 或者 [2,1]  </p></blockquote><p><strong>示例2：</strong> </p><blockquote><p>输入：arr = [0,1,2,1], k = 1<br>输出：[0]</p></blockquote><p><strong>限制：</strong></p><ul><li>0 <= k <= arr.length <= 10000</li><li>0 <= arr[i] <= 10000</li></ul><p><strong>我的解题：</strong></p><p>首先将数组arr从小到大排序，使用的排序算法不限（我使用的是插入排序），然后在声明一个长度为k的数组a，将排序后的数组arr一一赋值给a，最后返回a</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) {</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        sort(arr);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i < k;i++){</span><br><span class="line">            a[i]=arr[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i < arr.length;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j > <span class="number">0</span> && arr[j]<arr[j-<span class="number">1</arr[j-<span></span>];j--){<br><span class="line">                <span class="keyword">int</span> t = arr[j];</span><br><span class="line">                arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">                arr[j-<span class="number">1</span>] = t;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>执行结果：通过<br>执行用时 :180 ms<br>内存消耗 :41.7 MB  </p><p><strong>另一种解法：用快排最最最高效解决TopK问题</strong>  </p><p>注意找前 K 大/前 K 小问题不需要对整个数组进行 O(NlogN)O(NlogN)O(NlogN) 的排序！<br>例如本题，直接通过快排切分排好第 K小的数（下标为K-1），那么它左边的数就是比它小的另外 K-1 个数啦～</p><p>下面代码给出了详细的注释，没啥好啰嗦的，就是快排模版要记牢哈～</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) {</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || arr.length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 最后一个参数表示我们要找的是下标为k-1的数</span></span><br><span class="line">        <span class="keyword">return</span> quickSearch(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] quickSearch(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> k) {</span><br><span class="line">        <span class="comment">// 每快排切分1次，找到排序后下标为j的元素，如果j恰好等于k就返回j以及j左边所有的数；</span></span><br><span class="line">        <span class="keyword">int</span> j = partition(nums, lo, hi);</span><br><span class="line">        <span class="keyword">if</span> (j == k) {</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(nums, j + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 否则根据下标j与k的大小关系来决定继续切分左段还是右段。</span></span><br><span class="line">        <span class="keyword">return</span> j > k? quickSearch(nums, lo, j - <span class="number">1</span>, k): quickSearch(nums, j + <span class="number">1</span>, hi, k);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快排切分，返回下标j，使得比nums[j]小的数都在j的左边，比nums[j]大的数都在j的右边。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> v = nums[lo];</span><br><span class="line">        <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            <span class="keyword">while</span> (++i <= hi && nums[i] < v);</span><br><span class="line">            <span class="keyword">while</span> (--j >= lo && nums[j] > v);</span><br><span class="line">            <span class="keyword">if</span> (i >= j) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">int</span> t = nums[j];</span><br><span class="line">            nums[j] = nums[i];</span><br><span class="line">            nums[i] = t;</span><br><span class="line">        }</span><br><span class="line">        nums[lo] = nums[j];</span><br><span class="line">        nums[j] = v;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>快排切分时间复杂度分析：</strong> 因为我们是要找下标为k的元素，第一次切分的时候需要遍历整个数组 (0 ~ n) 找到了下标是 j 的元素，假如 k 比 j 小的话，那么我们下次切分只要遍历数组 (0~k-1)的元素就行啦，反之如果 k 比 j 大的话，那下次切分只要遍历数组 (k+1～n) 的元素就行啦，总之可以看作每次调用 partition 遍历的元素数目都是上一次遍历的 1/2，因此时间复杂度是 N + N/2 + N/4 + … + N/N = 2N, 因此时间复杂度是 <strong>O(N)O(N)O(N)。</strong></p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;面试题40-最小的k个数&quot;&gt;&lt;a href=&quot;#面试题40-最小的k个数&quot; class=&quot;headerlink&quot; title=&quot;面试题40. 最小的k个数&quot;&gt;&lt;/a&gt;面试题40. 最小的k个数&lt;/h1&gt;&lt;p&gt;&lt;st
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://kingstonxzj.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://kingstonxzj.github.io/tags/leetcode/"/>
    
      <category term="排序" scheme="https://kingstonxzj.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>java多线程基础（一）：进程与线程的基本概念</title>
    <link href="https://kingstonxzj.github.io/2020/04/02/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://kingstonxzj.github.io/2020/04/02/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2020-04-02T06:20:26.000Z</published>
    <updated>2020-04-02T06:25:03.222Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="第一章-进程与线程"><a href="#第一章-进程与线程" class="headerlink" title="第一章 进程与线程"></a>第一章 进程与线程</h1><h2 id="1-1-进程的概念"><a href="#1-1-进程的概念" class="headerlink" title="1.1 进程的概念"></a>1.1 进程的概念</h2><p><strong>进程就是应用程序在内存中分配的空间，也就是正在运行的程序</strong>，各个进程之间互不干扰。同时进程保存着程序每一时刻运行的状态</p><blockquote><p>程序：用某种编程语言（java、python等）编写，能够完成一定任务或者功能的代码集合，是指令和数据的有序集合，是一段静态代码。  </p></blockquote><p><strong>CPU采用时间片轮转的方式运行进程：</strong> CPU为每个进程分配⼀个时间段，称 作它的时间⽚。如果在时间⽚结束时进程还在运⾏，则暂停这个进程的运⾏，并且<br>CPU分配给另⼀个进程（这个过程叫做<strong>上下⽂切换</strong>）。如果进程在时间⽚结束前阻 塞或结束，则CPU⽴即进⾏切换，不⽤等待时间⽚⽤完。  </p><p><strong>进程让操作系统的并发成为了可能</strong>。虽然并发从宏观上看有多个 任务在执⾏，但在事实上，对于单核CPU来说，任意具体时刻都只有⼀个任务在占 ⽤CPU资源。</p><h3 id="1-1-1-线程的概念"><a href="#1-1-1-线程的概念" class="headerlink" title="1.1.1 线程的概念"></a>1.1.1 线程的概念</h3><p><strong>让一个线程执行一个子任务，这样一个进程就包含了多个线程，每个线程负责一个单独的子任务。</strong></p><p>进程让操作系统的并发性成为了可能，⽽<strong>线程让进程的内部并发成为了可能</strong>。</p><h3 id="1-1-2-多线程的好处："><a href="#1-1-2-多线程的好处：" class="headerlink" title="1.1.2 多线程的好处："></a>1.1.2 多线程的好处：</h3><ul><li><p>进程间的通信⽐较复杂，⽽线程间的通信⽐较简单，通常情况下，我们需要使 ⽤<strong>共享资源</strong>，这些资源<strong>在线程间的通信⽐较容易。</strong></p></li><li><p>进程是重量级的，⽽线程是轻量级的，故多线程⽅式的<strong>系统开销更⼩。</strong></p></li></ul><h3 id="1-1-3-进程和线程的区别："><a href="#1-1-3-进程和线程的区别：" class="headerlink" title="1.1.3 进程和线程的区别："></a>1.1.3 进程和线程的区别：</h3><p>他们两个的本质区别是<strong>是否单独占有内存地址空间及其它系统资源（⽐如I/O）</strong>：</p><ul><li><p>进程单独占有⼀定的内存地址空间，⽽线程共享所属进程占有的内存地址空间和资源</p></li><li><p>进程间存在内存隔离，数据是分开的，数据共享复杂但是同步简单；⽽线程数据共享简单，但是同步复杂。</p></li><li><p>⼀个进程出现问题不会影响其他进程，不影响主程序的稳定性，可靠性⾼；⼀个线程崩溃可能影响整个程序的稳定性，可靠性较低。 </p></li><li><p>进程的创建和销毁不仅需要保存寄存器和栈信息，还需要资源的分配回收以及⻚调度，开销较⼤；线程只需要保存寄存器和栈信息，开销较⼩。</p></li></ul><p>另外⼀个重要区别是，<strong>进程是操作系统进⾏资源分配的基本单位，⽽线程是操作系 统进⾏调度的基本单位，即CPU分配时间的单位。</strong></p><h2 id="1-2-上下文切换"><a href="#1-2-上下文切换" class="headerlink" title="1.2 上下文切换"></a>1.2 上下文切换</h2><p>上下文切换（进程切换或者任务切换）是指CPU从一个进程（或线程）切换到另一个进程（或线程）。上下文是指<strong>某一时间点CPU寄存器和程序计数器的内容</strong></p><p><strong>CPU通过为每个线程分配CPU时间⽚来实现多线程机制</strong>。CPU通过时间⽚分配算法来循环执⾏任务，当前任务执⾏⼀个时间⽚后会切换到下⼀个任务。</p><p>但是，在切换前会保存上⼀个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以<strong>任务从保存到再加载的过程就是⼀次上下⽂切换</strong>。</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;第一章-进程与线程&quot;&gt;&lt;a href=&quot;#第一章-进程与线程&quot; class=&quot;headerlink&quot; title=&quot;第一章 进程与线程&quot;&gt;&lt;/a&gt;第一章 进程与线程&lt;/h1&gt;&lt;h2 id=&quot;1-1-进程的概念&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="java基础" scheme="https://kingstonxzj.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="https://kingstonxzj.github.io/tags/java/"/>
    
      <category term="基础" scheme="https://kingstonxzj.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="https://kingstonxzj.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="https://kingstonxzj.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>算法基础--排序：选择排序与插入排序</title>
    <link href="https://kingstonxzj.github.io/2020/04/02/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80--%E6%8E%92%E5%BA%8F%EF%BC%9A%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%89/"/>
    <id>https://kingstonxzj.github.io/2020/04/02/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80--%E6%8E%92%E5%BA%8F%EF%BC%9A%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%89/</id>
    <published>2020-04-01T17:06:31.000Z</published>
    <updated>2020-04-02T06:28:08.676Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="排序算法类模板"><a href="#排序算法类模板" class="headerlink" title="排序算法类模板"></a>排序算法类模板</h1><p>约定：我们会将排序代码放在类中的sort()方法中，该类还将包含辅助函数less()和exch()以及一个测试用例main()。</p><p>less()方法对元素进行比较，exch()方法将元素交换位置。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排序算法的具体操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>{</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断两个元素哪个更小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) < <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将元素交换位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{</span><br><span class="line">        Comparable t = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable[] a)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < a.length; i++) {</span><br><span class="line">            System.out.println(a[i] + <span class="string">" "</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试数组是否有序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(Comparable[] a)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i < a.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (less(a[i], a[i - <span class="number">1</span>])) {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        String[] a = {<span class="string">"S"</span>,<span class="string">"O"</span>,<span class="string">"R"</span>,<span class="string">"T"</span>,<span class="string">"E"</span>,<span class="string">"X"</span>,<span class="string">"A"</span>,<span class="string">"M"</span>,<span class="string">"P"</span>,<span class="string">"L"</span>,<span class="string">"E"</span>};</span><br><span class="line">        sort(a);</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a)</span></span>;</span><br><span class="line">        show(a);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这个类展示的是数组排序实现的框架。对于我们学习的每种排序算法，我们都会为这样一个类实现一个sort()方法并将Example改为算法的名称。</p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p><strong>最简单的排序算法（选择排序）：不断地选择剩余元素之中的最小者，</strong> 步骤如下：</p><ol><li>找到数组中最小的那个元素</li><li>将它和数组中的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）</li><li>在剩下的元素中找到最小的元素，将他和第二个元素交换位置</li><li>如此往复，直到将整个数组排序</li></ol><p>选择排序的内循环只是在比较当前元素与目前已知的最小元素（以及将当前索引加1和检查代码是否越界）。交换元素的代码写在内循环之外，每次交换都能排定一个元素，因此交换的总次数是N。所以算法的时间效率取决于比较的次数（交换次数和数组的大小式成线性关系）</p><p>选择排序有两个鲜明的特点：运行时间和输入无关；数据移动式最少的。</p><h2 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h2><p><a href="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/algorithm/sort/selectionSort.gif" data-fancybox="group" data-caption="选择排序" class="fancybox"><img alt="选择排序" data-src="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/algorithm/sort/selectionSort.gif" class="lazyload" title="选择排序"></a></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Selection</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        <span class="comment">//将a[i]和a[i+1...N]中最小的元素交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < N; i++) {</span><br><span class="line">            <span class="comment">//最小元素的索引</span></span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j < N; j++) {</span><br><span class="line">                <span class="keyword">if</span> (less(a[j], a[min])) {</span><br><span class="line">                    min = j;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            exch(a, i, min);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//less()、exch()、isSorted()和main()方法见“排序算法模板”</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>时间复杂度：O(N^2)</strong></p><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p><strong>为了给要插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位，这种算法叫做插入排序。</strong></p><p>与选择排序一样，当前索引左边的所有元素都是有序的，但它们的最终位置还不确定，为了给更小的元素腾出空间，它们可能会被移动。但是<strong>当索引到达数组的右端时，数组排序就完成了。</strong><br>和选择排序不同的时，<strong>插入排序所需的时间取决于输入中元素的初始顺序。</strong>例如，对一个很大且其中的元素已经有序（或者接近有序）的数组进行排序将会比对随机顺序的数组或是逆序数组排序要快得多。</p><p>插入排序对实际应用中常见的某些类型<strong>的非随机数组很有效</strong>。它的运行时间也是线性的</p><h2 id="动图演示-1"><a href="#动图演示-1" class="headerlink" title="动图演示"></a>动图演示</h2><p><a href="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/algorithm/sort/insertionSort.gif" data-fancybox="group" data-caption="插入排序" class="fancybox"><img alt="插入排序" data-src="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/algorithm/sort/insertionSort.gif" class="lazyload" title="插入排序"></a></p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insertion</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i < N; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j > <span class="number">0</span> && less(a[j],a[j-<span class="number">1</span>]); j--) {</span><br><span class="line">                exch(a,j,j-<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//less()、exch()、isSorted()和main()方法见“排序算法模板”</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>时间复杂度：O(n^2)</strong></p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;排序算法类模板&quot;&gt;&lt;a href=&quot;#排序算法类模板&quot; class=&quot;headerlink&quot; title=&quot;排序算法类模板&quot;&gt;&lt;/a&gt;排序算法类模板&lt;/h1&gt;&lt;p&gt;约定：我们会将排序代码放在类中的sort()方法中
      
    
    </summary>
    
    
      <category term="算法" scheme="https://kingstonxzj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="基础" scheme="https://kingstonxzj.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="排序" scheme="https://kingstonxzj.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="算法" scheme="https://kingstonxzj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://kingstonxzj.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：两数之和</title>
    <link href="https://kingstonxzj.github.io/2020/04/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>https://kingstonxzj.github.io/2020/04/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2020-04-01T15:18:56.000Z</published>
    <updated>2020-04-01T15:29:48.650Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h1><p><strong>难度：简单</strong></p><p><strong>题目：</strong> 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p><strong>示例：</strong></p><blockquote><p>给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]  </p></blockquote><p><strong>我的解法：暴力解法</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < nums.length; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j < nums.length; j++) {</span><br><span class="line">                <span class="keyword">if</span> (nums[j] == target - nums[i]) {</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] { i, j };</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>执行结果：</strong> 通过<br><strong>执行用时 :</strong> 188 ms<br><strong>内存消耗 :</strong> 40 MB  </p><p><strong>复杂度分析：</strong><br>时间复杂度  | 空间复杂度<br>—|—<br>O(n2) | O(1)<br>O(n^2) | O(1)<br>O(n2) | O(1)</p><p><strong>官方题解：两遍哈希表</strong>  </p><p>为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。</p><p>通过<strong>以空间换取速度</strong>的方式，我们可以将查找时间从 O(n)O(n)O(n) 降低到 O(1)O(1)O(1)。哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)O(n)O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)O(1)O(1)。</p><p>一个简单的实现使用了两次迭代。<strong>在第一次迭代中，我们将每个元素的值和它的索引添加到表中。</strong> <strong>然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target−nums[i]target - nums[i]target−nums[i]）是否存在于表中。</strong> 注意，该目标元素不能是 nums[i]nums[i]nums[i] 本身！</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) {</span><br><span class="line">        Map<integer, integer> map = <span class="keyword">new</span> HashMap<>();</integer,></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < nums.length; i++) {</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < nums.length; i++) {</span><br><span class="line">            <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(complement) && map.get(complement) != i) {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] { i, map.get(complement) };</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>复杂度分析：</strong></p><p><strong>时间复杂度：O(n)O(n)O(n)，</strong><br>我们把包含有 nnn 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1)O(1)O(1) ，所以时间复杂度为 O(n)O(n)O(n)。</p><p><strong>空间复杂度：O(n)O(n)O(n)，</strong><br>所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 nnn 个元素</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;1-两数之和&quot;&gt;&lt;a href=&quot;#1-两数之和&quot; class=&quot;headerlink&quot; title=&quot;1.两数之和&quot;&gt;&lt;/a&gt;1.两数之和&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;难度：简单&lt;/strong&gt;&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://kingstonxzj.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://kingstonxzj.github.io/tags/leetcode/"/>
    
      <category term="数组" scheme="https://kingstonxzj.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：用两个栈实现队列</title>
    <link href="https://kingstonxzj.github.io/2020/04/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>https://kingstonxzj.github.io/2020/04/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</id>
    <published>2020-04-01T11:34:52.000Z</published>
    <updated>2020-04-01T17:15:35.369Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="面试题09-用两个栈实现队列"><a href="#面试题09-用两个栈实现队列" class="headerlink" title="面试题09.用两个栈实现队列"></a>面试题09.用两个栈实现队列</h2><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <strong><em>appendTail</em></strong> 和 <strong><em>deleteHead</em></strong> ，分别完成在<strong>队列尾部插入整数</strong>和在<strong>队列头部删除整数</strong>的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><p><strong>示例1：</strong></p><blockquote><p>输入：<br>[“CQueue”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[3],[],[]]</p><p>输出：[null,null,3,-1]</p></blockquote><p><strong>示例2：</strong></p><blockquote><p>输入：<br>[“CQueue”,”deleteHead”,”appendTail”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[],[5],[2],[],[]]</p><p>输出：[null,-1,null,null,5,2]</p></blockquote><p><strong>提示：</strong></p><ul><li>1 <= values <= 10000</li><li>最多会对 appendTail、deleteHead 进行 10000 次调用</li></ul><p><strong>官方题解</strong></p><p><strong>方法：一个栈存储元素，一个栈辅助</strong></p><p>维护两个栈，第一个栈存储元素，第二个栈用于辅助操作。</p><p>根据栈的特性，<strong>第一个栈的底部元素是最后插入的元素，第一个栈的顶部元素是下一个被删除的元素。</strong> 为了维护队列的特性，每次插入的元素应该在第一个栈的底部。因此<strong>每次插入元素时，若第一个栈内已经有元素，应将已有的全部元素依次弹出并压入第二个栈，然后将新元素压入第一个栈，最后将第二个栈内的全部元素依次弹出并压入第一个栈。</strong> 经过上述操作，新插入的元素在第一个栈的底部，第一个栈内的其余元素的顺序和插入元素之前保持一致。</p><p><strong>删除元素时，若第一个栈非空，则直接从第一个栈内弹出一个元素并返回，若第一个栈为空，则返回 -1。</strong></p><p><strong>另外维护队列的元素个数，用于判断队列是否为空。初始元素个数为 0。每次插入元素，元素个数加 1。每次删除元素，元素个数减 1。</strong></p><p><strong>插入元素</strong></p><p>插入元素对应方法 appendTail</p><ul><li>如果 stack1 非空，则将 stack1 内的元素依次弹出并依次压入 stack2，直至 stack1 内的全部元素都被弹出</li><li>将新元素 value 压入 stack1 内</li><li>如果 stack2 非空，则将 stack2 内的元素依次弹出并依次压入 stack1，直至 stack2 内的全部元素都被弹出</li><li>将 size 的值加 1</li></ul><p><strong>删除元素</strong></p><p>删除元素对应方法 deleteHead</p><ul><li>如果 size 为 0，则队列为空，返回 -1</li><li>如果 size 大于 0，则队列非空，将 size 的值减 1，从 stack1 弹出一个元素并返回</li></ul><p><strong>复杂度分析</strong></p><p>插入元素</p><ul><li>时间复杂度：<strong>O(n)O(n)O(n)。</strong>插入元素时，对于已有元素，每个元素都要弹出栈两次，压入栈两次，因此是线性时间复杂度。</li><li>空间复杂度：<strong>O(n)O(n)O(n)。</strong>需要使用额外的空间存储已有元素。</li></ul><p>删除元素</p><ul><li>时间复杂度：<strong>O(1)O(1)O(1)</strong>。判断元素个数和删除队列头部元素都使用常数时间。</li><li>空间复杂度：<strong>O(1)O(1)O(1)</strong>。从第一个栈弹出一个元素，使用常数空间。<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>{</span><br><span class="line">    Stack<integer> stack1;</integer></span><br><span class="line">    Stack<integer> stack2;</integer></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>{</span><br><span class="line">        stack1 = <span class="keyword">new</span> Stack<integer>();</integer></span><br><span class="line">        stack2 = <span class="keyword">new</span> Stack<integer>();</integer></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (!stack1.isEmpty()) {</span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        }</span><br><span class="line">        stack1.push(value);</span><br><span class="line">        <span class="keyword">while</span> (!stack2.isEmpty()) {</span><br><span class="line">            stack1.push(stack2.pop());</span><br><span class="line">        }</span><br><span class="line">        size++;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> stack1.pop();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行结果：通过</span><br><span class="line">显示详情执行用时: 337 ms</span><br><span class="line">内存消耗: 48.3 MB</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 id=&quot;面试题09-用两个栈实现队列&quot;&gt;&lt;a href=&quot;#面试题09-用两个栈实现队列&quot; class=&quot;headerlink&quot; title=&quot;面试题09.用两个栈实现队列&quot;&gt;&lt;/a&gt;面试题09.用两个栈实现队列&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://kingstonxzj.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://kingstonxzj.github.io/tags/leetcode/"/>
    
      <category term="栈" scheme="https://kingstonxzj.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://kingstonxzj.github.io/2020/04/01/hello-world/"/>
    <id>https://kingstonxzj.github.io/2020/04/01/hello-world/</id>
    <published>2020-03-31T16:43:35.596Z</published>
    <updated>2020-03-31T16:43:35.602Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure></div><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure></div><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure></div><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure></div><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Che
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
