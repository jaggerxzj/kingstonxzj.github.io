<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>七皇</title>
  <icon>https://www.gravatar.com/avatar/251e30a005fcf60528a5524a099f5065</icon>
  <subtitle>qihuang</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://qihuang7.top/"/>
  <updated>2020-04-13T16:08:53.415Z</updated>
  <id>https://qihuang7.top/</id>
  
  <author>
    <name>七皇</name>
    <email>qihuang7@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java多线程基础（十二）：阻塞队列</title>
    <link href="https://qihuang7.top/2020/04/13/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>https://qihuang7.top/2020/04/13/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</id>
    <published>2020-04-13T12:18:26.000Z</published>
    <updated>2020-04-13T16:08:53.415Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="阻塞队列的由来"><a href="#阻塞队列的由来" class="headerlink" title="阻塞队列的由来"></a>阻塞队列的由来</h1><h2 id="生产者-消费者模式"><a href="#生产者-消费者模式" class="headerlink" title="生产者-消费者模式"></a>生产者-消费者模式</h2><blockquote><p><strong>生产者-消费者模式</strong>：生产者一直生产资源，消费者一直消费资源，<strong>资源存储在一个缓冲池中</strong>，生产者将生产的资源存进缓冲池中，消费者从缓冲池中拿到资源进行消费。</p></blockquote><p>该模式能够简化开发过程，一方面消除了生产者类与消费者类之间的代码依赖性，另一方面将生产数据的过程与使用数据的过程解耦简化负载。</p><p>因为<strong>需要让多个线程操作共享变量</strong>（即资源），所以很<strong>容易引发线程安全问题</strong>，造成<strong>重复消费和死锁</strong>，尤其是⽣产者和消费者存在多个的情况。</p><p>另外，当缓冲池空了，我们需要阻塞消费者，唤醒⽣产者；当缓冲池满了，我们需要阻塞⽣产者，唤醒消费者，这些个<strong>等待-唤醒逻辑</strong>都需要⾃⼰实现。</p><p>阻塞队列（Blocking Queue）会帮我们实现这个等待-唤醒逻辑。</p><blockquote><p>BlockQueue一般用于生产者-消费者模式，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程，<strong>BlockingQueue就是存放元素的容器</strong></p></blockquote><h1 id="阻塞队列的主要方法"><a href="#阻塞队列的主要方法" class="headerlink" title="阻塞队列的主要方法"></a>阻塞队列的主要方法</h1><table><thead><tr><th>方法/处理方式</th><th>抛出异常</th><th>返回特殊值</th><th>一直阻塞</th><th>超时退出</th></tr></thead><tbody><tr><td>插入方法</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e,time,unit)</td></tr><tr><td>移除方法</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time,unit)</td></tr><tr><td>检查方法</td><td>element()</td><td>peek()</td><td></td><td></td></tr></tbody></table><ul><li>抛出异常：如果试图的操作无法立即执行，抛异常。当阻塞队列满的时候，再往队列里插入元素，会抛出IllegalStateException(“Queue full”)异常。当队列为空时，从队列里获取元素时会抛出NoSuchElementException异常。</li><li>返回特殊值：如果试图的操作无法立即执行，返回一个特殊值，通常是true/false。</li><li>一直阻塞：如果试图的操作无法立即执行，则一直阻塞或者响应中断。</li><li>超时退出：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功，通常是true/false。</li></ul><h1 id="BlockingQueue的实现类"><a href="#BlockingQueue的实现类" class="headerlink" title="BlockingQueue的实现类"></a>BlockingQueue的实现类</h1><h2 id="ArrayBlockingQueue（公平、非公平）"><a href="#ArrayBlockingQueue（公平、非公平）" class="headerlink" title="ArrayBlockingQueue（公平、非公平）"></a>ArrayBlockingQueue（公平、非公平）</h2><p>由数组结构组成的有界阻塞队列。内部结构是数组，故具有数组的特性。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span></span>{</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以初始化队列大小，且一旦初始化不能改变。构造方法中的fair表示控制对象的内部锁是否采用公平锁，<strong>默认是非公平锁，即默认情况下不保证访问者公平的访问队列</strong>。通常情况下为了保证公平性会降低吞吐量。</p><blockquote><p>所谓<strong>公平访问队列</strong>是指阻塞的所有生产者或者消费者线程，当队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入元素，先阻塞的消费者线程，可以先从队列里获取元素。</p></blockquote><h2 id="LinkedBlockingQueue（两个独立锁提高并发）"><a href="#LinkedBlockingQueue（两个独立锁提高并发）" class="headerlink" title="LinkedBlockingQueue（两个独立锁提高并发）"></a>LinkedBlockingQueue（两个独立锁提高并发）</h2><p>由链表结构组成的有界阻塞队列。默认队列大小是Integer.MAX_VALUE，也可以指定大小。此队列按照先进先出的原则对元素进行排序。</p><p>LinkedBlockingQueue之所以能够<strong>高效的处理并发数据</strong>，是因为其<strong>对于生产者端和消费者端分别采用了独立的锁来控制数据同步</strong>。这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中地数据，以此来提高整个队列地并发性能。</p><h2 id="DelayQueue（缓存失效、定时任务）"><a href="#DelayQueue（缓存失效、定时任务）" class="headerlink" title="DelayQueue（缓存失效、定时任务）"></a>DelayQueue（缓存失效、定时任务）</h2><p><strong>支持延时获取元素的无界阻塞队列</strong>。队列使用 PriorityQueue（优先队列） 来实现。队列中的元素必须实现 Delayed 接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。我们可以将DelayQueue运用在以下应用场景：</p><ol><li>缓存系统的设计：可以用 DelayQueue 保存缓存元素的有效期，使用一个线程循环查询 DelayQueue，，一旦能从 DelayQueue 中获取元素时，表示缓存有效期到了。</li><li>定时任务调度：使用 DelayQueue 保存当天将会执行的任务和执行时间，一旦从 DelayQueue 中获取到任务就开始执行，比如 TimerQueue 就是使用 DelayQueue 实现的。</li></ol><h2 id="PriorityBlockingQueue（compareTo排序实现优先）"><a href="#PriorityBlockingQueue（compareTo排序实现优先）" class="headerlink" title="PriorityBlockingQueue（compareTo排序实现优先）"></a>PriorityBlockingQueue（compareTo排序实现优先）</h2><p><strong>支持优先级排序的无界阻塞队列</strong>。默认情况下元素采取自然顺序升序排序。可以自定义实现compareTo()方法来指定元素进行排序规则，或者初始化PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序</p><h2 id="LinkedTransferQueue："><a href="#LinkedTransferQueue：" class="headerlink" title="LinkedTransferQueue："></a>LinkedTransferQueue：</h2><p>由链表结构组成的无界阻塞队列。</p><h2 id="LinkedBlockingQueue："><a href="#LinkedBlockingQueue：" class="headerlink" title="LinkedBlockingQueue："></a>LinkedBlockingQueue：</h2><p>由链表结构组成的双向阻塞队列。所谓双向队列指的你可以从队列的两端插入和移出元素。双端队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。<br>在初始化 LinkedBlockingDeque 时可以设置容量防止其过渡膨胀。另外双向阻塞队列可以运用在“工作窃取”模式中。</p><h2 id="SynchronousQueue："><a href="#SynchronousQueue：" class="headerlink" title="SynchronousQueue："></a>SynchronousQueue：</h2><p>不存储元素的阻塞队列。</p><h1 id="阻塞队列的原理"><a href="#阻塞队列的原理" class="headerlink" title="阻塞队列的原理"></a>阻塞队列的原理</h1><p>阻塞队列的原理很简单，<strong>利用了Lock锁的多条件（Condition）阻塞控制</strong>。</p><h2 id="分析ArrayBlockingQueue的源码"><a href="#分析ArrayBlockingQueue的源码" class="headerlink" title="分析ArrayBlockingQueue的源码"></a>分析ArrayBlockingQueue的源码</h2><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据元素数组</span></span><br><span class="line"><span class="keyword">final</span> Object[] items;</span><br><span class="line"><span class="comment">//下⼀个待取出元素索引</span></span><br><span class="line"><span class="keyword">int</span> takeIndex;</span><br><span class="line"><span class="comment">//下⼀个待添加元素索引</span></span><br><span class="line"><span class="keyword">int</span> putIndex;</span><br><span class="line"><span class="comment">//元素个数</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="comment">//内部锁</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"><span class="comment">//消费者监视器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"><span class="comment">//⽣产者监视器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>{</span><br><span class="line">    <span class="comment">//...省略其他代码</span></span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull = lock.newCondition();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>首先是构造器，除了初始化队列的大小和是否是公平锁之外，还对同一个锁 （lock）初始化了两个监视器，分别是notEmpty和notFull。<strong>这两个监视器的作用目前可以简单理解为标记分组</strong>，当该线程是put操作时，给他加上监视器notFull，标记这个线程是一个生产者；当线程是take操作时，给他加上监视器notEmpty，标记这个线程是消费者。</p><h3 id="put操作的源码"><a href="#put操作的源码" class="headerlink" title="put操作的源码"></a>put操作的源码</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 1.⾃旋拿锁</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 2.判断队列是否满了</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            <span class="comment">// 2.1如果满了，阻塞该线程，并标记为notFull线程，</span></span><br><span class="line">            <span class="comment">// 等待notFull的唤醒，唤醒之后继续执⾏while循环。</span></span><br><span class="line">            notFull.await();</span><br><span class="line">        <span class="comment">// 3.如果没有满，则进⼊队列</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>{</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">    putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="comment">// 4 唤醒⼀个等待的线程</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>put的流程：<br>总结put的流程： </p><ol><li>所有执行put操作的线程竞争lock锁，拿到了lock锁的线程进⼊下⼀步，没有拿到lock锁的线程自旋竞争锁。 </li><li>判断阻塞队列是否满了，如果满了，则调用await方法阻塞这个线程，并标记为 notFull（⽣产者）线程，同时释放lock锁，等待被消费者线程唤醒。</li><li>如果没有满，则调用enqueue方法将元素put进阻塞队列。注意这一步的线程还有一种情况是第二步中阻塞的线程被唤醒且又拿到了lock锁的线程。</li><li>唤醒一个标记为notEmpty（消费者）的线程。</li></ol><h3 id="take操作的源码"><a href="#take操作的源码" class="headerlink" title="take操作的源码"></a>take操作的源码</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">        notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>take操作和put操作类似，流程如下：</p><ol><li>所有执行take操作的线程竞争lock锁，拿到了lock锁的线程进入下一步，没有拿到 lock锁的线程自旋竞争锁。 </li><li>判断阻塞队列是否为空，如果是空，则调用await方法阻塞这个线程，并标记为 notEmpty（消费者）线程，同时释放lock锁,等待被生产者线程唤醒。 </li><li>如果没有空，则调用dequeue方法。注意这一步的线程还有一种情况是第二步中阻塞的线程被唤醒且又拿到了lock锁的线程。 </li><li>唤醒一个标记为notFull（⽣产者）的线程。</li></ol><h1 id="示例和使用场景"><a href="#示例和使用场景" class="headerlink" title="示例和使用场景"></a>示例和使用场景</h1><h2 id="生产者-消费者模型"><a href="#生产者-消费者模型" class="headerlink" title="生产者-消费者模型"></a>生产者-消费者模型</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> queueSize = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> ArrayBlockingQueue<integer> queue = <span class="keyword">new</span> ArrayBlockingQueue<integer></integer></integer></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        Producer producer = test.<span class="keyword">new</span> Producer();</span><br><span class="line">        Consumer consumer = test.<span class="keyword">new</span> Consumer();</span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    }</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        consume();</span><br><span class="line">        }</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>){</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    queue.take();</span><br><span class="line">                    System.out.println(<span class="string">"从队列取走一个元素，队列剩余"</span>+queue.size()+<span class="string">"个元素"</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            produce();</span><br><span class="line">        }</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>){</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    queue.put(<span class="number">1</span>);</span><br><span class="line">                    System.out.println(<span class="string">"向队列取中插入一个元素，队列剩余空间："</span>+(queueSize-queue.size()));</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">    从队列取走一个元素，队列剩余0个元素</span></span><br><span class="line"><span class="comment">    从队列取走一个元素，队列剩余0个元素</span></span><br><span class="line"><span class="comment">    向队列取中插入一个元素，队列剩余空间：9</span></span><br><span class="line"><span class="comment">    向队列取中插入一个元素，队列剩余空间：9</span></span><br><span class="line"><span class="comment">    向队列取中插入一个元素，队列剩余空间：9</span></span><br><span class="line"><span class="comment">    向队列取中插入一个元素，队列剩余空间：8</span></span><br><span class="line"><span class="comment">    向队列取中插入一个元素，队列剩余空间：7</span></span><br><span class="line"><span class="comment">    向队列取中插入一个元素，队列剩余空间：6</span></span><br><span class="line"><span class="comment">    向队列取中插入一个元素，队列剩余空间：5</span></span><br><span class="line"><span class="comment">    向队列取中插入一个元素，队列剩余空间：4</span></span><br><span class="line"><span class="comment">    向队列取中插入一个元素，队列剩余空间：3</span></span><br><span class="line"><span class="comment">    向队列取中插入一个元素，队列剩余空间：2</span></span><br><span class="line"><span class="comment">    向队列取中插入一个元素，队列剩余空间：1</span></span><br><span class="line"><span class="comment">    向队列取中插入一个元素，队列剩余空间：0</span></span><br><span class="line"><span class="comment">    从队列取走一个元素，队列剩余1个元素</span></span><br><span class="line"><span class="comment">    从队列取走一个元素，队列剩余9个元素</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure></div><p>注意，这个例子中的输出结果看起来可能有问题，比如有几行在插入一个元素之后，队列的剩余空间不变。这是由于System.out.println语句没有锁。考虑到这样的情况：线程1在执行完put/take操作后立即失去CPU时间片，然后切换到线程2执行put/take操作，执行完毕后回到线程1的System.out.println语句并输出，发现这个时候阻塞队列的size已经被线程2改变了，所以这个时候输出的size并不是当时线程1执行完put/take操作之后阻塞队列的size，但可以确保的是size不会超过10个。实际上使用阻塞队列是没有问题的。</p><h2 id="线程池中使用阻塞队列"><a href="#线程池中使用阻塞队列" class="headerlink" title="线程池中使用阻塞队列"></a>线程池中使用阻塞队列</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                           TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                           BlockingQueue<runnable> workQueue)</runnable></span> </span>{</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>Java中的线程池就是使用阻塞队列实现的，我们在了解阻塞队列之后，无论是使用 Exectors类中已经提供的线程池，还是自己通过ThreadPoolExecutor实现线程池，都会更加得心应手，想要了解线程池的同学，可以看第十二站：线程池原理。</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;阻塞队列的由来&quot;&gt;&lt;a href=&quot;#阻塞队列的由来&quot; class=&quot;headerlink&quot; title=&quot;阻塞队列的由来&quot;&gt;&lt;/a&gt;阻塞队列的由来&lt;/h1&gt;&lt;h2 id=&quot;生产者-消费者模式&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="java基础" scheme="https://qihuang7.top/categories/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="https://qihuang7.top/categories/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://qihuang7.top/tags/java/"/>
    
      <category term="基础" scheme="https://qihuang7.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="线程池" scheme="https://qihuang7.top/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>java多线程基础（十二）：阻塞队列</title>
    <link href="https://qihuang7.top/2020/04/13/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9A%E9%94%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB/"/>
    <id>https://qihuang7.top/2020/04/13/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9A%E9%94%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB/</id>
    <published>2020-04-13T12:18:26.000Z</published>
    <updated>2020-04-14T11:21:50.014Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="synchronized的不足之处"><a href="#synchronized的不足之处" class="headerlink" title="synchronized的不足之处"></a>synchronized的不足之处</h1><ul><li>如果临界区是只读操作，其实可以多线程一起执行，但使用synchronized的话，<strong>同一时间只能有一个线程执行</strong>。</li><li>synchronized无法知道线程有没有成功获取到锁。</li><li>使用synchronized，如果临界区因为IO或者sleep方法等原因阻塞了，而当前线程又没有释放锁，就会导致<strong>所有线程等待</strong>。</li></ul><h1 id="锁的几种分类"><a href="#锁的几种分类" class="headerlink" title="锁的几种分类"></a>锁的几种分类</h1><h2 id="可重入锁-ReentrantLock-和不可重入锁"><a href="#可重入锁-ReentrantLock-和不可重入锁" class="headerlink" title="可重入锁(ReentrantLock)和不可重入锁"></a>可重入锁(ReentrantLock)和不可重入锁</h2><p>所谓重入锁，顾名思义。就是支持重新进入的锁，也就是说这个锁<strong>支持一个线程对资源重复加锁</strong>。</p><p>synchronized关键字就是使用的重入锁。比如说，你在一个synchronized实例方法里面调用另一个本实例的synchronized实例方法，它可以重新进入这个锁，不会出现任何异常。</p><p>如果我们自己在继承AQS实现同步器的时候，没有考虑到占有锁的线程再次获取锁的场景，肯就会导致线程阻塞，那这就是一个“不可重入锁”。</p><h2 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h2><p>这里的“公平”，通俗意义来说就是“先来后到”，也就是FIFO。如果对一个锁来说，先对锁获取请求的线程一定会先被满足，后对锁获取请求的线程后被满足，那这个锁就是公平的。反之，那就是不公平的。</p><p>一般情况下，<strong>非公平锁能提升一定的效率。但是非公平锁可能会发送线程饥饿（有一些线程长时间得不到锁）的情况。</strong>所以要根据实际的需求来选择非公平锁和公平锁。</p><p>ReentrantLock支持公平锁和非公平锁两种。</p><h2 id="读写锁和排他锁"><a href="#读写锁和排他锁" class="headerlink" title="读写锁和排他锁"></a>读写锁和排他锁</h2><p>前面讲到的 <strong>synchronized用的锁和ReentrantLock，其实都是“排他锁”</strong>。也就是说，<strong>这些锁在同一时刻只允许一个线程进行访问</strong>。</p><p>而<strong>读写锁可以在同一时刻允许多个读线程访问。</strong>Java提供了ReentrantReadWriteLock类作为读写锁的默认实现，内部维护了两个锁：<strong>读锁和写锁</strong>。通过分离读锁和写锁，使得在<strong>“读多写少”</strong>的环境下大大地提高了性能。</p><blockquote><p>即使用读写锁，在写线程访问时，所有的读线程和其他写线程均被阻塞。</p></blockquote><h1 id="JDK中有关锁的一些接口和类"><a href="#JDK中有关锁的一些接口和类" class="headerlink" title="JDK中有关锁的一些接口和类"></a>JDK中有关锁的一些接口和类</h1><h2 id="抽象类AQS-AQLS-AOS"><a href="#抽象类AQS-AQLS-AOS" class="headerlink" title="抽象类AQS/AQLS/AOS"></a>抽象类AQS/AQLS/AOS</h2><p><strong>AQS</strong>(AbstractQueuedSynchronized)是在JDK 1.5发布对的，提供了一个“队列同步器”的基本功能实现。而AQS里面的资源是用一个int类型的数据来表示的，有时候我们的业务需求资源的数量超出了int的访问，所以在JDK 1.6中，多了一个<strong>AQLS</strong>(AbstractQueuedLongSynchronized)。它的代码跟AQS几乎一样，<strong>只是把资源的类型变成了long类型</strong>。</p><p>AQS和AQLS都继承了一个类叫<strong>AOS</strong>(AbstractOwnableSynchronizer)。这个类只有几行简单的代码。它是用于表示锁与持有者之间的关系（独占模式）。</p><h2 id="接口Condition-Lock-ReadWriteLock"><a href="#接口Condition-Lock-ReadWriteLock" class="headerlink" title="接口Condition/Lock/ReadWriteLock"></a>接口Condition/Lock/ReadWriteLock</h2><p>Lock接口里面有一些获取锁和释放锁的方法声明，而ReadWriteLock里面只有两个方法，分别返回“读锁”和“写锁”：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>{</span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>Lock接口中有一个方法是可以获得一个Condition：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure></div><p>每个对象都可以用继承自 <strong>Object的wait/notify方法来实现等待/通知机制</strong>。而Condition接口也提供了类似Object监视器的方法，<strong>通过与Lock配合来实现等待/通知机制</strong>。</p><table><thead><tr><th>对比项</th><th>Object监视器</th><th>Condition</th></tr></thead><tbody><tr><td>前置条件</td><td>获取对象的锁</td><td>调用Lock.lock获取锁，调用Lock.newCondition获取Condition对象</td></tr><tr><td>调用方式</td><td>直接调用，比如object.notify()</td><td>直接调用，比如condition.await()</td></tr><tr><td>等待队列的个数</td><td>一个</td><td>多个</td></tr><tr><td>当前线程释放锁进入等待状态</td><td>支持</td><td>支持</td></tr><tr><td>当前线程释放锁进入等待状态，在等待状态中不中断</td><td>不支持</td><td>支持</td></tr><tr><td>当前线程释放锁并进入超时状态</td><td>支持</td><td>支持</td></tr><tr><td>当前线程释放锁并进入等待状态直到将来的某个时间</td><td>不支持</td><td>支持</td></tr><tr><td>唤醒等待队列中的一个线程</td><td>支持</td><td>支持</td></tr><tr><td>唤醒等待队列中的全部线程</td><td>支持</td><td>支持</td></tr></tbody></table><p>Condition类似于Object的等待/通知机制的加强版。</p><h2 id="ReentrantLock（可重入锁）"><a href="#ReentrantLock（可重入锁）" class="headerlink" title="ReentrantLock（可重入锁）"></a>ReentrantLock（可重入锁）</h2><p>ReentrantLock是一个非抽象类，它是Lock接口的JDK默认实现，实现了锁的基本功能。</p><p>从源码上看，他内部有一个抽象类Sync，是继承了AQS，自己实现的一个同步器。同时，ReentrantLock内部有两个非抽象类 NonfairSync 和 FairSync，他们都继承了Sync。从名字上看得出，分别是“非公平同步器”和“公平同步器”的意思。这意味着<strong>ReentrantLock可以支持“公平锁”和“非公平锁”。</strong></p><p>这两个同步器的实现都是“独占”的。都调用了AOS的setExclusiveOwnerThread方法，所以，**ReentrantLock的锁是“独占”的，即它的锁都是“排他锁”，不能共享。</p><h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><p>这个类也是一个非抽象类，它是ReadWriteLock接口的JDK默认实现。它与ReentrantLock的功能类似，也是可重入的，支持公平锁和非公平锁。不同的是，它还支持<strong>“读写锁”</strong>。</p><p>它内部同样维护了两个同步器，而且维护了两个Lock的实现类ReadLock和WriteLock，这两个内部类用的是外部类的同步器。</p><p>ReentrantReadWriteLock实现了读写锁，但它有一个小弊端，<strong>就是在“写”操作的时候，其它线程不能写也不能读。这种现象称为“写饥饿”。</strong></p><h2 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h2><p>StampedLock类是在java8才发布的。它没有实现Lock接口和ReadWriteLock接口，但它其实是实现了“读写锁”的功能，并且性能比ReentrantReadWriteLock更改。</p><p><strong>StampedLock还把读锁分为了“乐观读锁”和“悲观读锁”两种。</strong></p><p>它的核心思想在于：<strong>在读的时候如果发生了写，应该通过重试的方式来获取新的值，而不应该阻塞写操作。这种模式也就是典型的无锁编程思想，和CAS自旋的思想一样。</strong></p><p>这种操作方式决定了StampedLock在读线程非常多而写线程非常少的场景下非常使用，同时还避免了写饥饿情况的发生。</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;synchronized的不足之处&quot;&gt;&lt;a href=&quot;#synchronized的不足之处&quot; class=&quot;headerlink&quot; title=&quot;synchronized的不足之处&quot;&gt;&lt;/a&gt;synchroniz
      
    
    </summary>
    
    
      <category term="java基础" scheme="https://qihuang7.top/categories/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="https://qihuang7.top/categories/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://qihuang7.top/tags/java/"/>
    
      <category term="基础" scheme="https://qihuang7.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="锁" scheme="https://qihuang7.top/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>java多线程基础（十一）：线程池原理</title>
    <link href="https://qihuang7.top/2020/04/12/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/"/>
    <id>https://qihuang7.top/2020/04/12/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/</id>
    <published>2020-04-12T15:18:26.000Z</published>
    <updated>2020-04-12T15:19:35.746Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="为什么要使用线程池？"><a href="#为什么要使用线程池？" class="headerlink" title="为什么要使用线程池？"></a>为什么要使用线程池？</h1><p>使用线程池主要有以下三个原因：</p><ol><li>创建/销毁线程需要消耗系统资源，线程池可以<strong>复用已创建的线程。</strong></li><li><strong>控制并发的数量。</strong>并发数量过多，可能会导致资源消耗过多，从而造成服务器崩溃（主要原因）</li><li><strong>可以对线程做统一管理。</strong></li></ol><h1 id="线程池的原理"><a href="#线程池的原理" class="headerlink" title="线程池的原理"></a>线程池的原理</h1><p>线程池顶层接口是 Executor接口，ThreadPoolExecutor 是这个接口的实现类。</p><p>线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量<strong>超出数量的线程排队等候</strong>，等其它线程执行完毕，再从队列中取出任务来执行。他的主要特点为：<strong>线程复用；控制最大并发数；管理线程。</strong></p><h2 id="线程复用"><a href="#线程复用" class="headerlink" title="线程复用"></a>线程复用</h2><p><strong>线程复用：即一个线程执行完线程任务后不销毁，继续执行另外的线程任务</strong></p><p>每一个Thread的类都有一个start方法。当调用start启动线程时Java虚拟机会调用该类的run方法。那么该类的run()方法中就是调用了Runnable对象的run()方法。我们可以继承重写Thread类，在其start方法中添加不断循环调用传递过来的Runnable对象。这就是线程池的实现原理。循环方法中不断获取Runnable是用Queue实现的，在获取下一个Runnable之前可以是阻塞的。</p><h2 id="线程池的组成"><a href="#线程池的组成" class="headerlink" title="线程池的组成"></a>线程池的组成</h2><p>一般的线程池主要分为以下4个组成部分：</p><ol><li>线程池管理器：用于创建并管理线程</li><li>工作线程：线程池中的线程</li><li>任务接口：每个任务必须实现的接口，用于工作线程调度其运行</li><li>任务队列：用于存放待处理的任务，提供一种缓冲机制</li></ol><p>线程池是通过 Executor 框架实现的，该框架中用到了 Executor，Executors，ExecutorService，ThreadPoolExecutor，Callable和Future、FutureTask这几个类</p><p><strong>ThreadPoolExecutor提供的构造方法</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(  <span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                            TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                            BlockingQueue<runnable> workQueue,</runnable></span></span></span><br><span class="line"><span class="function"><span class="params">                            ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                            RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></tbody></table></figure></div><p>必须的5个参数：</p><ul><li>corePoolSize：该线程池中<strong>核心线程数最大值</strong></li><li>maximumPoolSize：该线程池中<strong>线程总数最大值</strong>（等于核心线程数量+非核心线程数量）</li><li>keepAliveTime：<strong>非核心线程闲置超时时长</strong>，当前线程池数量超过corePoolSize时，多余的空闲线程的存活时间，即多次时间内会被销毁。</li><li>unit：keepAliveTime的单位，是一个枚举类型。</li><li>workQueue：阻塞队列/任务队列，维护着<strong>等待执行的Runnable任务对象。</strong></li></ul><p>2个非必须参数：</p><ul><li>threadFactory：创建线程的工厂，用于批量创建线程，统一在创建线程时设置一些参数，如是否守护线程、线程的优先级。如不指定，会新建一个默认的线程工厂。</li><li>handle：<strong>拒绝处理策略</strong>，线程数量大于最大线程数就会采用拒绝处理策略</li></ul><h3 id="拒绝处理的策略"><a href="#拒绝处理的策略" class="headerlink" title="拒绝处理的策略"></a>拒绝处理的策略</h3><p>线程池中的线程已经用完了，无法继续为新任务服务，同时，等待队列也已经排满了，再也塞不下新任务了。这时候我们就需要拒绝策略机制合理的处理这个问题。</p><p>拒绝策略如下：</p><ol><li>AbortPolicy：<strong>默认拒绝处理策略</strong>，丢弃任务并抛出RejectedExecutionException异常</li><li>DiscardPolicy：该策略默默地丢弃无法处理地任务，不与任何处理。如果允许任务丢失，这是最好的一种方案。</li><li>DiscardOldersPolicy：丢弃队列头部（最旧的）任务，然后重新尝试执行程序（如果再次失败，重复此过程）</li><li>CallerRunsPolicy：只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会极具下降</li></ol><blockquote><p>以上内置拒绝策略均实现了 RejectedExecutionHandler 接口，若以上策略仍无法满足实际需要，完全可以自己扩展 RejectedExecutionHandler 接口。</p></blockquote><h1 id="线程池工作过程"><a href="#线程池工作过程" class="headerlink" title="线程池工作过程"></a>线程池工作过程</h1><ol><li>线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。</li><li>当调用execute()方法添加一个任务时，线程池会做如下判断：<ol><li>如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务；</li><li>如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列；</li><li>如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</li><li>如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常 RejectExecutionException。</li></ol></li><li>当一个线程完成任务时，它会从队列中取下一个任务来执行。</li><li>当一个线程无事可做，超过一定时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到corePoolSize的大小。</li></ol><p><a href="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.PNG" data-fancybox="group" data-caption="线程池工作过程" class="fancybox"><img alt="线程池工作过程" title="线程池工作过程" data-src="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.PNG" class="lazyload"></a></p><h1 id="四种常见的线程池"><a href="#四种常见的线程池" class="headerlink" title="四种常见的线程池"></a>四种常见的线程池</h1><ul><li>CacheThreadPool：当需要执行很多短时间的任务时，CacheThreadPool的线程复用率比较高，会显著提高性能，而且60s后会回收，意味着即使没有任务进来，CacheThreadPool并不会占用很多资源。CacheThreadPool<strong>只会创建非核心线程。</strong></li><li>FixedThreadPool：如果核心线程空闲，则交给核心线程处理；如果核心线程不空闲，则入列等待，直到核心线程空闲。 FixedThreadPool<strong>只会创建核心线程。</strong></li><li>SingleThreadExecutor：有且仅有一个核心线程（corePoolSize==maximumPoolSize=1），使用了LinkedBlockingQueue（容量很大），所以 <strong>不会创建非核心线程</strong>。所有任务按照先来先执行的顺序执行。</li><li>ScheduledThreadPool：定长线程池，支持定时及周期性任务执行</li></ul></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;为什么要使用线程池？&quot;&gt;&lt;a href=&quot;#为什么要使用线程池？&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用线程池？&quot;&gt;&lt;/a&gt;为什么要使用线程池？&lt;/h1&gt;&lt;p&gt;使用线程池主要有以下三个原
      
    
    </summary>
    
    
      <category term="java基础" scheme="https://qihuang7.top/categories/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="https://qihuang7.top/categories/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://qihuang7.top/tags/java/"/>
    
      <category term="基础" scheme="https://qihuang7.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="线程池" scheme="https://qihuang7.top/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>java多线程基础（十）：AQS抽象队列同步器</title>
    <link href="https://qihuang7.top/2020/04/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9AAQS%E6%8A%BD%E8%B1%A1%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8/"/>
    <id>https://qihuang7.top/2020/04/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9AAQS%E6%8A%BD%E8%B1%A1%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8/</id>
    <published>2020-04-10T13:18:26.000Z</published>
    <updated>2020-04-10T13:31:00.425Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="AQS简介"><a href="#AQS简介" class="headerlink" title="AQS简介"></a>AQS简介</h1><p>AQS是 AbstractQueuedSynchronizer 的简称，即 <strong>抽象队列同步器</strong>，</p><h2 id="AQS的作用"><a href="#AQS的作用" class="headerlink" title="AQS的作用"></a>AQS的作用</h2><p>AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛地同步器，比如我们提到地ReentrantLock（可重入锁），Semaphore（信号量），ReentrantReadWriteLock（可重入读写锁），SynchronousQueue（同步队列/阻塞队列），FutureTask等等皆是基于AQS的。</p><p>只要实现它的几个 protected方法就可以利用AQS非常容易地构造出符合我们自己需求的同步器。</p><h1 id="AQS的数据结构"><a href="#AQS的数据结构" class="headerlink" title="AQS的数据结构"></a>AQS的数据结构</h1><p>AQS内部使用了一个 volatile 的变量state来作为资源的标识。同时定义了几个获取和改变state的protected方法，子类可以覆盖这些方法来实现自己的逻辑：<br>getState()、setState()、compareAndSetState()</p><p><strong>这三种均是原子操作</strong>，其中，compareAndSetState 的实现依赖于 Unsafe 的 compareAndSwapInt()方法。</p><p>AQS类本身实现的是一些 <strong>排队和阻塞</strong>的机制，比如具体线程等待队列的维护（如获取资源失败入队/唤醒队列等）。它内部使用了一个先进先出（FIFO）的 <strong>双端队列</strong>，并使用了两个指针head和tail用于标识队列的头部和尾部。</p><p>数据结构如图：</p><p><a href="http://concurrent.redspider.group/article/02/imgs/AQS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" data-fancybox="group" data-caption="AQS的数据结构图" class="fancybox"><img alt="AQS的数据结构图" title="AQS的数据结构图" data-src="http://concurrent.redspider.group/article/02/imgs/AQS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" class="lazyload"></a></p><p>但它并不是直接储存线程，⽽是储存拥有线程的Node节点。</p><h1 id="资源共享模式"><a href="#资源共享模式" class="headerlink" title="资源共享模式"></a>资源共享模式</h1><p>资源有两种共享模式，或者说两种同步方式：</p><ul><li>独占模式（Exclusive）：资源是独占的，一次只能一个线程获取。如ReentrantLock</li><li>共享模式（Share）：同时可以被多个线程获取，具体的资源个数可以通过参数指定。如Semaphore/CountDownLatch。</li></ul><blockquote><p>一般情况下，子类只需要根据需求实现其中一种模式，当然也有同时实现两种模式的同步类，如ReadWriteLock。</p></blockquote><h1 id="AQS的主要方法"><a href="#AQS的主要方法" class="headerlink" title="AQS的主要方法"></a>AQS的主要方法</h1><p>AQS的设计是 <strong>基于模板方法模式</strong> 的，它有一些方法必须要子类去实现的：</p><ul><li><p>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</p></li><li><p>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</p></li><li><p>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</p></li><li><p>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</p></li><li><p>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</p></li></ul><p>这些方法都是protected方法，但是它们并没有在AQS具体实现，而是直接抛出异常</p><p><strong>为什么不使用抽象方法实现？</strong></p><blockquote><p>之所以没有定义成 abstract，是因为独占模式下只用实现 tryAcquire-tryRelease ，而共享模式下只用实现 tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。不同的自定义同步器争用共享资源的方式也不同。</p></blockquote><h2 id="获取资源"><a href="#获取资源" class="headerlink" title="获取资源"></a>获取资源</h2><p><a href="http://concurrent.redspider.group/article/02/imgs/acquire%E6%B5%81%E7%A8%8B.jpg" data-fancybox="group" data-caption="获取资源的流程图" class="fancybox"><img alt="获取资源的流程图" title="获取资源的流程图" data-src="http://concurrent.redspider.group/article/02/imgs/acquire%E6%B5%81%E7%A8%8B.jpg" class="lazyload"></a></p><p>获取资源的入口是 acquire(int arg)方法。arg是要获取的资源个数，独占模式下始终为1。</p><p>首先调用 tryAcquire(arg) 尝试去获取资源，如果失败，就通过 addWaiter(Node.EXCLUSIVE) 方法把这个线程 <strong>插入到等待队列中</strong>，其中传入的参数代表要插入的Node是独占式的。</p><p><strong>在结点进入等待队列后，调用park使它进入阻塞状态的，只要头结点的线程是处于活跃状态的。</strong></p><p>获取资源的方法除了acquire之外还有以下三个：</p><ul><li>acquireInterruptibly：申请可中断的资源（独占模式）</li><li>acquireShared：申请共享模式的资源</li><li>acquireSharedInterruptibly：申请可中断的资源（共享模式）</li></ul><blockquote><p>可中断的意思是，在线程中断时可能会抛出InterruptedException</p></blockquote><h1 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h1><h2 id="独占模式（以ReentrantLock为例）"><a href="#独占模式（以ReentrantLock为例）" class="headerlink" title="独占模式（以ReentrantLock为例）"></a>独占模式（以ReentrantLock为例）</h2><p>以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。</p><p>A 线程 lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失败，直到 A 线程 unlock()到 state=0（即释放锁）为止，其它线程才有机会获取该锁。</p><p>当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。</p><p>但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的</p><h2 id="共享模式（以CountDownLatch为例）"><a href="#共享模式（以CountDownLatch为例）" class="headerlink" title="共享模式（以CountDownLatch为例）"></a>共享模式（以CountDownLatch为例）</h2><p>以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与<br>线程个数一致）。</p><p>这 N 个子线程是并行执行的，每个子线程执行完后 countDown()一次，state<br>会 CAS 减 1。</p><p>等到所有子线程都执行完后(即 state=0)，会 unpark()主调用线程，然后主调用线程就会从 await()函数返回，继续后序动作。</p><h2 id="同时实现两种（ReentrantReadWriteLock）"><a href="#同时实现两种（ReentrantReadWriteLock）" class="headerlink" title="同时实现两种（ReentrantReadWriteLock）"></a>同时实现两种（ReentrantReadWriteLock）</h2></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;AQS简介&quot;&gt;&lt;a href=&quot;#AQS简介&quot; class=&quot;headerlink&quot; title=&quot;AQS简介&quot;&gt;&lt;/a&gt;AQS简介&lt;/h1&gt;&lt;p&gt;AQS是 AbstractQueuedSynchronizer 的
      
    
    </summary>
    
    
      <category term="java基础" scheme="https://qihuang7.top/categories/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="https://qihuang7.top/categories/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://qihuang7.top/tags/java/"/>
    
      <category term="基础" scheme="https://qihuang7.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="AQS" scheme="https://qihuang7.top/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>算法基础--排序：快速排序 *</title>
    <link href="https://qihuang7.top/2020/04/10/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80--%E6%8E%92%E5%BA%8F%EF%BC%9A%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>https://qihuang7.top/2020/04/10/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80--%E6%8E%92%E5%BA%8F%EF%BC%9A%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</id>
    <published>2020-04-10T07:34:31.000Z</published>
    <updated>2020-04-10T07:38:58.496Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p><strong>应用最广泛的排序算法。</strong> 它实现简单、适用于各种不同的输入数据且在一般应用中比其他排序算法都要快得多。</p><p>特点：原地排序（只需要要一个很小的辅助栈），且将长度为N的数组排序所需要的实践和NlgN成正比。另外，快速排序的内循环比大多数排序算法都要短小，这意味着它无论是在理论上还是在实际中都要更快。</p><p>它的主要缺点是非常脆弱，在实现时要非常小心才能避免低劣的性能。</p><h2 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h2><p>快速排序是一种 <strong>分治</strong> 的排序算法。它将一个数组分成两个子数组，将两部分独立地排序。快速排序和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序；而快速排序将数组排序的方法则是当两个子数组都有序时整个数组也就自然有序了。</p><p>在第一种情况中，递归调用发送在处理整个数组之前；在第二种情况中，递归调用发生在处理整个数组之后。在归并排序中，一个数组被等分为两半；在快速排序中，切分（partition）的位置取决于数组的内容。</p><p><strong>动图演示</strong><br><a href="https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif" data-fancybox="group" data-caption="快速排序" class="fancybox"><img alt="快速排序" title="快速排序" data-src="https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif" class="lazyload"></a></p><p><strong>代码实现：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>{</span><br><span class="line">    sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (hi <= lo) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> j = partition(a, lo, hi);   <span class="comment">//切分</span></span><br><span class="line">    sort(a, lo, j - <span class="number">1</span>);     <span class="comment">//将左半部分a[lo....j-1]排序</span></span><br><span class="line">    sort(a, j + <span class="number">1</span>, hi);     <span class="comment">//将右半部分a[j+1....hi]排序</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>该方法的关键在于切分，这个过程使得数组满足下面三个条件：</p><ul><li>对于某个j，a[j]已经排定</li><li>a[lo]到a[j-1]中的所有元素都不大于a[j]</li><li>a[j+1]到a[hi]中的所有元素都不小于a[i]</li></ul><blockquote><p>通过递归地调用切分来排序的,一般策略是：先随意地 <strong>取a[lo]作为切分元素</strong>，即那个将会被排定的元素，然后我们从数组的 <strong>左端开始向右扫描直到找到一个大于等于它的元素，再从数组的右端开始向左扫描直到找到一个小于等于它的元素。</strong> 显然这两个元素是没有排定的，因此我们 <strong>交换它的位置</strong>。如此继续，我们就可以保证左指针i的左侧元素都不大于切分元素，右指针j的右侧元素都不小于切分元素。<strong>当两个指针相遇时，我们只需要将切分元素a[lo]和左子数组最右侧的元素a[j]交换然后返回j即可</strong></p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] a,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span> </span>{</span><br><span class="line">    <span class="comment">//将数组切分为a[lo..i-1],a[i],a[i+1..hi]</span></span><br><span class="line">    <span class="keyword">int</span> i = lo,j = hi + <span class="number">1</span>;</span><br><span class="line">    Comparable v = a[lo];</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>){</span><br><span class="line">        <span class="keyword">while</span> (less(a[++i],a[v])){</span><br><span class="line">            <span class="keyword">if</span>(i == hi) <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (less(v,a[--j])) {</span><br><span class="line">            <span class="keyword">if</span>(j == lo) <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(i >= j) <span class="keyword">break</span>;</span><br><span class="line">        exch(a,i,j);</span><br><span class="line">    }</span><br><span class="line">    exch(a,lo,j);   <span class="comment">//将v = a[j]放入正确的位置</span></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这段代码按照 a[lo] 的值v进行切分。当指针i和j相遇时主循环退出。在循环中，a[i]小于v时，我们增大i，a[j]大于v时我们减小j，然后交换a[i]和a[j]来保证i左侧的元素都不大与v，j右侧的元素都不小于v。当指针相遇时交换a[lo]和a[j],切分结束（这样切分值九留在a[j]中了）。</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;应用最广泛的排序算法。&lt;/strong&gt; 它实现简单、适用
      
    
    </summary>
    
    
      <category term="算法" scheme="https://qihuang7.top/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="https://qihuang7.top/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="排序" scheme="https://qihuang7.top/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="基础" scheme="https://qihuang7.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="算法" scheme="https://qihuang7.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://qihuang7.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>算法基础--排序：归并排序（自顶向下和自底向上）</title>
    <link href="https://qihuang7.top/2020/04/09/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80--%E6%8E%92%E5%BA%8F%EF%BC%9A%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>https://qihuang7.top/2020/04/09/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80--%E6%8E%92%E5%BA%8F%EF%BC%9A%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2020-04-09T15:00:31.000Z</published>
    <updated>2020-04-09T15:01:26.608Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p><strong>归并：将两个有序的数组归并成一个更大的有序数组。</strong></p><p>优点：它能够保证将任意长度为N的数组排序所需的实际和N logN成正比<br>缺点：它所需要的额外空间和N成正比</p><h2 id="原地归并的抽象方法"><a href="#原地归并的抽象方法" class="headerlink" title="原地归并的抽象方法"></a>原地归并的抽象方法</h2><p>实现归并的一种直截了当的办法就是将两个不同的有序数组归并到第三个数组中，两个数组应该都实现Comparable接口。<br>实现的方法很简单，<strong>创建一个适当大小的数组然后将两个输入数组中的元素一个个从小到大放入数组。</strong></p><p>当用归并将一个大数组排序时，我们需要进行很多此归并，因此在每次归并时都创建一个新数组来存储排序结果会带来问题。我们更希望有一种能够在原地归并的方法，这样就可以先将前半部分排序，再将后半部分排序，然后在数组中移动元素而不需要使用额外的空间。</p><p><strong>动图演示：</strong></p><p><a href="https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif" data-fancybox="group" data-caption="归并排序" class="fancybox"><img alt="归并排序" title="归并排序" data-src="https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif" class="lazyload"></a></p><p><strong>原地归并代码实现：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k <= hi; k++) {    <span class="comment">//将a[lo..hi]复制到aux[lo..hi]中</span></span><br><span class="line">        aux[k] = a[k];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k <= hi; k++) {</span><br><span class="line">        <span class="keyword">if</span> (i > mid) {</span><br><span class="line">            a[k] = aux[j++];</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (j > hi) {</span><br><span class="line">            a[k] = aux[i++];</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (less(aux[j], aux[i])) {</span><br><span class="line">            a[k] = aux[j++];</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            a[k] = aux[i++];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>在归并时进行了四个判断：</p><ul><li>左半边用尽                                （取右半边的元素）</li><li>右半边用尽                                （取左半边的元素）</li><li>右半边的当前元素小于左半边的当前元素      （取右半边的元素）</li><li>右半边的当前元素大于等于左半边的当前元素  （取左半边的元素）</li></ul><h2 id="自顶向上的归并排序"><a href="#自顶向上的归并排序" class="headerlink" title="自顶向上的归并排序"></a>自顶向上的归并排序</h2><p>基于原地归并的抽象实现了另一种 <strong>递归归并</strong>，这也是应用高效算法设计中 <strong>分治思想</strong> 的最典型的一个例子，他就能通过归并两个子数组将整个数组排序</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merge</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux;    <span class="comment">//归并所需的辅助数组</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>{</span><br><span class="line">        aux = <span class="keyword">new</span> Comparable[a.length];</span><br><span class="line">        sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (hi <= lo) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        sort(a, lo, mid);       <span class="comment">//左半边排序</span></span><br><span class="line">        sort(a, mid + <span class="number">1</span>, hi);   <span class="comment">//右半边排序</span></span><br><span class="line">        merge(a, lo, mid, hi);  </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="自底向上的归并排序"><a href="#自底向上的归并排序" class="headerlink" title="自底向上的归并排序"></a>自底向上的归并排序</h2><p>实现归并排序的另一种方法就 <strong>是先归并那些微型数组</strong>，然后再将成对归并得到的子数组，如此这般，直到我们将整个数组归并到一起。</p><blockquote><p>这种实现方式比标准递归方法所需的代码量更少。首先我们进行的是两两归并，（把每个元素想象成一个大小为1的数组），然后是四四归并（将两个大小为2的数组归并成一个有4个元素的数组），然后是八八归并，一直下去，最后一次归并的第二个子数组可能比第一个子数组要小（但这对merge()方法不是问题）</p></blockquote><p><strong>代码实现：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeBU</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        aux = <span class="keyword">new</span> Comparable[N];</span><br><span class="line">        <span class="comment">//sz：子数组大小，从1开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> sz = <span class="number">1</span>; sz < N; sz = sz + sz) {        </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> lo = <span class="number">0</span>; lo < N - sz; lo += sz + sz) {  <span class="comment">//lo：子数组索引</span></span><br><span class="line">                merge(a, lo, lo + sz - <span class="number">1</span>, Math.min(lo + sz + sz - <span class="number">1</span>, N - <span class="number">1</span>));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>自底向上的归并排序会多次遍历整个数组，根据子数组的大小进行两两归并。子数组的大小sz的初始值为1，每次加倍。最后一个子数组的大小只有在数组大小是sz的偶数倍的时候才会等于sz（否则他会比sz小）</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;归并排序&quot;&gt;&lt;a href=&quot;#归并排序&quot; class=&quot;headerlink&quot; title=&quot;归并排序&quot;&gt;&lt;/a&gt;归并排序&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;归并：将两个有序的数组归并成一个更大的有序数组。&lt;/str
      
    
    </summary>
    
    
      <category term="算法" scheme="https://qihuang7.top/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="https://qihuang7.top/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="排序" scheme="https://qihuang7.top/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="基础" scheme="https://qihuang7.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="算法" scheme="https://qihuang7.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://qihuang7.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java多线程基础（九）：乐观锁和悲观锁</title>
    <link href="https://qihuang7.top/2020/04/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/"/>
    <id>https://qihuang7.top/2020/04/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/</id>
    <published>2020-04-09T14:18:26.000Z</published>
    <updated>2020-04-09T08:35:33.700Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h1><p>锁可以从不同的角度分类。其中，乐观锁和悲观锁是一种分类方式。</p><p><strong>悲观锁：</strong></p><p>悲观锁就是我们常说的锁。对于悲观锁来说，它总是认为每次访问共享资源时会发生冲突，所以必须对每次数据操作加上锁，以保证临界区的程序同一时间只能有一个线程在执行。</p><p><strong>乐观锁：</strong></p><p>乐观锁又称为“无锁”，顾名思义，它是乐观锁。乐观锁总是假设对共享资源的访问没有冲突，线程可以不停地执行，无需加锁也无需等待。而一旦多个线程发生冲突，乐观锁通常是使用一种称为CAS的技术来保证线程执行的安全性。</p><p>由于无锁操作中没有锁的存在，因此不可能出现死锁的情况，也就是说 <strong>乐观锁天生免疫死锁</strong>。</p><p><strong>乐观锁多用于“读多写少”的环境，避免频繁加锁影响性能；而悲观锁多用于“写多读少”的环境，避免频繁失败和重试影响性能。</strong></p><h1 id="CAS的概念"><a href="#CAS的概念" class="headerlink" title="CAS的概念"></a>CAS的概念</h1><p>CAS是乐观锁的一种实现，CAS的全称是：比较并交换（Compare And Swap）。在CAS中，有这样三个值：</p><ul><li>V：要更新的变量（var）</li><li>E：预期值（expected）</li><li>N：新值（new）</li></ul><p>比较并交换的过程如下：</p><p>判断V是否等于E，如果等于，将V的值设置为N；如果不等，说明已经有其他线程更新了V，则当前线程放弃更新，什么都不做。</p><p>所以这里的 <strong>预期值E本质上指的是“旧值”。</strong></p><p>一个简单的例子来解释这个过程：</p><blockquote><ol><li>如果有一个多个线程共享的变量i原本等于5，我现在在线程A中，想把它设置为新的值6;  </li><li>我们使用CAS来做这个事情；  </li><li>首先我们用i去与5对比，发现它等于5，说明没有被其它线程改过，那我就把它设置为新的值6，此次CAS成功，i的值被设置成了6；  </li><li>如果不等于5，说明i被其它线程改过了（比如现在i的值为2），那么我就什么也不做，此次CAS失败，i的值仍然为2。</li></ol></blockquote><p>在这个例子中，i 就是 V，5 就是 E，6 就是 N。</p><p>有没有可能我在判断了 i 为 5 之后，正准备更新它的新值的时候，被其他线程更改了 i 的值呢？</p><blockquote><p>答案是不会的，因为 <strong>CAS是一种原子操作</strong>，它是一种系统原语，是一条CPU的原子指令，从CPU层面保证它的原子性。</p></blockquote><p><strong>当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并允许再次尝试，当然也允许失败的进程放弃操作。</strong></p><h1 id="CAS实现原子操作的三大问题"><a href="#CAS实现原子操作的三大问题" class="headerlink" title="CAS实现原子操作的三大问题"></a>CAS实现原子操作的三大问题</h1><h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><p>所谓ABA问题，就是一个值原来是A，变成了B，又变回了A。这个时候使用CAS是检查不出来变化的，但实际上却被更新了两次。</p><p>ABA问题的解决思路就是 <strong>在变量前面追加上版本号或者时间戳</strong>。从JDK1.5开始，JDK的atomic包里提供了一个类AtomicStampedReference类来解决ABA问题。</p><p>这个类的compareAndSet方法的作用首先是 <strong>检查当前引用是否等于预期引用 ，并检查当前标志是否等于预期标注</strong>，如果二者都相等，才使用CAS设置为新的值和标志。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                             V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> newStamp)</span> </span>{</span><br><span class="line">    Pair<v> current = pair;</v></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        expectedReference == current.reference &&</span><br><span class="line">        expectedStamp == current.stamp &&</span><br><span class="line">        ((newReference == current.reference &&</span><br><span class="line">          newStamp == current.stamp) ||</span><br><span class="line">         casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h2><p>CAS多与自旋结合。如果自旋CAS长时间不成功，会占大量的CPU资源。</p><p>解决思路是 <strong>让JVM支持处理器提供的 pause指令。</strong></p><p>pause指令 能让自旋失败时cpu睡眠一小段时间再继续自旋，从而使得读操作的频率低很多，为解决内存顺序冲突而导致的CPU流水线重排的代价也会小很多。</p><h2 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h2><p>有两种解决方案：</p><ol><li>使用JDK 1.5开始就提供的 AtomicReference 类保证对象之间的原子性，把多个变量放到一个对象里面进行CAS操作</li><li>使用锁。锁内的临界区代码可以保证只有当前线程能操作。</li></ol></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;乐观锁和悲观锁&quot;&gt;&lt;a href=&quot;#乐观锁和悲观锁&quot; class=&quot;headerlink&quot; title=&quot;乐观锁和悲观锁&quot;&gt;&lt;/a&gt;乐观锁和悲观锁&lt;/h1&gt;&lt;p&gt;锁可以从不同的角度分类。其中，乐观锁和悲观锁是一种
      
    
    </summary>
    
    
      <category term="java基础" scheme="https://qihuang7.top/categories/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="https://qihuang7.top/categories/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://qihuang7.top/tags/java/"/>
    
      <category term="基础" scheme="https://qihuang7.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="锁" scheme="https://qihuang7.top/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Spring基础（四）：Spring事务管理</title>
    <link href="https://qihuang7.top/2020/04/09/%E6%A1%86%E6%9E%B6/Spring%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9ASpring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
    <id>https://qihuang7.top/2020/04/09/%E6%A1%86%E6%9E%B6/Spring%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9ASpring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</id>
    <published>2020-04-09T14:06:39.000Z</published>
    <updated>2020-04-10T07:32:03.298Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="事务（Transaction）"><a href="#事务（Transaction）" class="headerlink" title="事务（Transaction）"></a>事务（Transaction）</h1><p>一组业务操作，要么全部成功，要么全部失败回滚。</p><h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><p>事务具备ACID四种特性，ACID是 <strong>Atomic（原子性）、Consistency（一致性）、Isolation（隔离性）和Durability（持久性）</strong> 的英文缩写。</p><ol><li>原子性(Atomic)：事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。</li><li>一致性(Consistency)：一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状态，而不会是部分完成部分失败。在现实中的数据不应该被破坏。</li><li>隔离性(Isolation)：可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏</li><li>持久性(Durability)：一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来。通常情况下，事务的结果被写到持久化存储器中。</li></ol><h2 id="事务的传播特性"><a href="#事务的传播特性" class="headerlink" title="事务的传播特性"></a>事务的传播特性</h2><p><strong>事务的传播性一般用在事务嵌套的场景，比如一个事务方法里面调用了另外一个事务方法，那么两个方法是各自作为独立的方法提交还是内层的事务合并到外层的事务一起提交，这就是需要事务传播机制的配置来确定怎么样执行。</strong></p><p>Spring定义了7种传播行为：</p><ol><li><strong>propagation_requierd(默认)</strong>：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中。</li><li>propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。</li><li>propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。</li><li><strong>propagation_required_new</strong>：新建事务，如果当前存在事务，把当前事务挂起。</li><li>propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li><li>propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。</li><li><strong>propagation_nested</strong>：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作。</li></ol><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p><strong>事务的隔离级别定义一个事务可能受其他并发务活动活动影响的程度，可以把事务的隔离级别想象为这个事务对于事物处理数据的自私程度。</strong></p><p>在一个典型的应用程序中，多个事务同时运行，经常会为了完成他们的工作而操作同一个数据。并发虽然是必需的，但是会导致以下问题：</p><ol><li>脏读（Dirty read）：一个事务读到另一个事务没有提交的数据</li><li>不可重复读（Nonrepeatable read）：不可重复读发生在一个事务执行相同的查询两次或两次以上，但每次查询结果都不相同时。这通常是由于另一个并发事务在两次查询之间更新了数据。</li><li>幻读（Phantom reads）：幻读和不可重复读相似。当一个事务读取几行记录后，另一个并发事务插入了一些记录时，幻读就发生了。在后来的查询中，第一个事务就会发现一些原来没有的额外记录。</li></ol><p><strong>隔离级别：</strong></p><ul><li>read_uncommited：允许读取尚未提交的更改。可能导致脏读、幻读或不可重复读。</li><li>read_commited：（Oracle 默认级别）允许从已经提交的并发事务读取。可防止脏读，但幻读和不可重复读仍可能会发生。</li><li>repeatable_read：（MYSQL默认级别）对相同字段的多次读取的结果是一致的，除非数据被当前事务本身改变。可防止脏读和不可重复读，但幻读仍可能发生。</li><li>serializable：完全服从ACID的隔离级别，确保不发生脏读、不可重复读和幻影读。这在所有隔离级别中也是最慢的，因为它通常是通过完全锁定当前事务所涉及的数据表来完成的。</li></ul><h1 id="事务的几种实现方式"><a href="#事务的几种实现方式" class="headerlink" title="事务的几种实现方式"></a>事务的几种实现方式</h1><h2 id="编程式事务管理"><a href="#编程式事务管理" class="headerlink" title="编程式事务管理"></a>编程式事务管理</h2><p>对基于 POJO 的应用来说是唯一选择。我们需要在代码中调用beginTransaction()、commit()、rollback()等事务管理相关的方法，这就是编程式事务管理。</p><blockquote><p>编程式事务在实际开发中并没有广泛使用，所以主要介绍声明式事务管理</p></blockquote><h2 id="基于TransactionProxyFactoryBean的声明式事务管理"><a href="#基于TransactionProxyFactoryBean的声明式事务管理" class="headerlink" title="基于TransactionProxyFactoryBean的声明式事务管理"></a>基于TransactionProxyFactoryBean的声明式事务管理</h2><p>spring提供管理事务的代理工厂bean：TransactionProxyFactoryBean</p><blockquote><p>此处采用转账的业务，具体实现忽略</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><!-- 创建数据源 --></span></span><br><span class="line"><span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>></span></span><br><span class="line">....</span><br><span class="line"><span class="tag"><!--<span class="name"-->bean</span>></span><br><span class="line"><span class="comment"><!-- 配置dao --></span></span><br><span class="line"><span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountDaoImple"</span> <span class="attr">class</span>=<span class="string">"com.xzj.demo.AccountDaoImple"</span>></span></span><br><span class="line"><span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>></span><span class="tag"><!--<span class="name"-->property</span>></span><br><span class="line"><span class="tag"><!--<span class="name"-->bean</span>></span><br><span class="line"><span class="comment"><!-- 配置service --></span></span><br><span class="line"><span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountServiceImplId"</span> <span class="attr">class</span>=<span class="string">"com.xzj.demo.AccountServiceImpl"</span>></span></span><br><span class="line"><span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accountDao"</span> <span class="attr">ref</span>=<span class="string">"accountDaoImple"</span>></span><span class="tag"><!--<span class="name"-->property</span>></span><br><span class="line"><span class="tag"><!--<span class="name"-->bean</span>></span><br><span class="line"><span class="comment"><!-- 配置事务管理器 --></span></span><br><span class="line"><span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"txManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>></span></span><br><span class="line"><span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>></span><span class="tag"><!--<span class="name"-->property</span>></span><br><span class="line"><span class="tag"><!--<span class="name"-->bean</span>></span><br><span class="line"></span><br><span class="line"><span class="comment"><!-- 代理对象 </span></span><br><span class="line"><span class="comment">    proxyInterfaces：接口</span></span><br><span class="line"><span class="comment">    target：目标类</span></span><br><span class="line"><span class="comment">    transactionManager：事务管理器</span></span><br><span class="line"><span class="comment">    transactionAttributes：事务属性</span></span><br><span class="line"><span class="comment">--></span></span><br><span class="line"><span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"proxyAccountService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.transaction.interceptor.TransactionProxyFactoryBean"</span>></span></span><br><span class="line"><span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"proxyInterfaces"</span> <span class="attr">value</span>=<span class="string">"com.xzj.demo.AccountService"</span>></span><span class="tag"><!--<span class="name"-->property</span>></span><br><span class="line"><span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span> <span class="attr">ref</span>=<span class="string">"accountServiceImplId"</span>></span><span class="tag"><!--<span class="name"-->property</span>></span><br><span class="line"><span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"transactionManager"</span> <span class="attr">ref</span>=<span class="string">"txManager"</span>></span><span class="tag"><!--<span class="name"-->property</span>></span><br><span class="line"><span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"transactionAttributes"</span>></span></span><br><span class="line"><span class="tag"><<span class="name">props</span>></span></span><br><span class="line">    <span class="comment"><!--</span></span><br><span class="line"><span class="comment">        格式：传播行为、隔离级别、是否可读、-异常回滚、+异常提交</span></span><br><span class="line"><span class="comment">            例如：PROPAGATION_REQUIRED,ISOLATION_DEFAULT,readOnly</span></span><br><span class="line"><span class="comment">    --></span></span><br><span class="line"><span class="tag"><<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"transfer"</span>></span>PROPAGATION_REQUIRED,ISOLATION_DEFAULT<span class="tag"><!--<span class="name"-->prop</span>></span><br><span class="line"><span class="tag"><!--<span class="name"-->props</span>></span><br><span class="line"><span class="tag"><!--<span class="name"-->property</span>></span><br><span class="line"><span class="tag"><!--<span class="name"-->bean</span>></span><br></pre></td></tr></tbody></table></figure></div><h2 id="基于-Transactional的声明式事务管理"><a href="#基于-Transactional的声明式事务管理" class="headerlink" title="基于@Transactional的声明式事务管理"></a>基于@Transactional的声明式事务管理</h2><p>只需在service层的实现类的方法上加上@Transactional注解  </p><blockquote><p>例如：@Transactional(isolation=Isolation.DEFAULT,propagation=Propagation.REQUIRED,rollbackFor=BuyStockException.class)</p></blockquote><p>并修改配置文件</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><!-- 创建数据源 --></span></span><br><span class="line"><span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>></span></span><br><span class="line">....</span><br><span class="line"><span class="tag"><!--<span class="name"-->bean</span>></span><br><span class="line"><span class="comment"><!-- 配置dao --></span></span><br><span class="line"><span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountDaoImple"</span> <span class="attr">class</span>=<span class="string">"com.xzj.demo.AccountDaoImple"</span>></span></span><br><span class="line"><span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>></span><span class="tag"><!--<span class="name"-->property</span>></span><br><span class="line"><span class="tag"><!--<span class="name"-->bean</span>></span><br><span class="line"><span class="comment"><!-- 配置service --></span></span><br><span class="line"><span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountServiceImplId"</span> <span class="attr">class</span>=<span class="string">"com.xzj.demo.AccountServiceImpl"</span>></span></span><br><span class="line"><span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accountDao"</span> <span class="attr">ref</span>=<span class="string">"accountDaoImple"</span>></span><span class="tag"><!--<span class="name"-->property</span>></span><br><span class="line"><span class="tag"><!--<span class="name"-->bean</span>></span><br><span class="line"><span class="comment"><!-- 配置事务管理器 --></span></span><br><span class="line"><span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"txManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>></span></span><br><span class="line"><span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>></span><span class="tag"><!--<span class="name"-->property</span>></span><br><span class="line"><span class="tag"><!--<span class="name"-->bean</span>></span><br><span class="line"><span class="comment"><!-- 启用事务注解 --></span></span><br><span class="line"><span class="tag"><<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"myTracnsactionManager"</span>/></span></span><br></pre></td></tr></tbody></table></figure></div><h2 id="基于AspectJ-AOP配置事务"><a href="#基于AspectJ-AOP配置事务" class="headerlink" title="基于AspectJ AOP配置事务"></a>基于AspectJ AOP配置事务</h2><p>秩序修改配置文件，其他无需变化</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><!-- 事务管理器 --></span></span><br><span class="line">...</span><br><span class="line"><span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myTracnsactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>></span><span class="tag"><!--<span class="name"-->property</span>></span><br><span class="line"><span class="tag"><!--<span class="name"-->bean</span>></span><br><span class="line"></span><br><span class="line"><span class="tag"><<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"myTracnsactionManager"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">tx:attributes</span>></span></span><br><span class="line">        <span class="comment"><!-- 为连接点指定事务属性 --></span></span><br><span class="line">        <span class="tag"><<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"add*"</span> <span class="attr">isolation</span>=<span class="string">"DEFAULT"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/></span></span><br><span class="line">        <span class="tag"><<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"buyStock"</span> <span class="attr">isolation</span>=<span class="string">"DEFAULT"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">rollback-for</span>=<span class="string">"BuyStockException"</span>/></span></span><br><span class="line">    <span class="tag"><!--<span class="name"-->tx:attributes</span>></span><br><span class="line"><span class="tag"><!--<span class="name"-->tx:advice</span>></span><br><span class="line"></span><br><span class="line"><span class="tag"><<span class="name">aop:config</span>></span></span><br><span class="line">    <span class="comment"><!-- 切入点配置 --></span></span><br><span class="line">    <span class="tag"><<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* *..service.*.*(..))"</span> <span class="attr">id</span>=<span class="string">"point"</span>/></span></span><br><span class="line">    <span class="tag"><<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"point"</span>/></span></span><br><span class="line"><span class="tag"><!--<span class="name"-->aop:config</span>></span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;事务（Transaction）&quot;&gt;&lt;a href=&quot;#事务（Transaction）&quot; class=&quot;headerlink&quot; title=&quot;事务（Transaction）&quot;&gt;&lt;/a&gt;事务（Transaction）&lt;
      
    
    </summary>
    
    
      <category term="框架" scheme="https://qihuang7.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="spring" scheme="https://qihuang7.top/categories/%E6%A1%86%E6%9E%B6/spring/"/>
    
    
      <category term="基础" scheme="https://qihuang7.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="SSM" scheme="https://qihuang7.top/tags/SSM/"/>
    
      <category term="spring" scheme="https://qihuang7.top/tags/spring/"/>
    
      <category term="事务" scheme="https://qihuang7.top/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java集合：Map（主要介绍 HashMap）</title>
    <link href="https://qihuang7.top/2020/04/09/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%EF%BC%9AMap%EF%BC%88%E4%B8%BB%E8%A6%81%E4%BB%8B%E7%BB%8DHashMap%EF%BC%89/"/>
    <id>https://qihuang7.top/2020/04/09/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%EF%BC%9AMap%EF%BC%88%E4%B8%BB%E8%A6%81%E4%BB%8B%E7%BB%8DHashMap%EF%BC%89/</id>
    <published>2020-04-09T10:27:26.000Z</published>
    <updated>2020-04-10T08:48:24.834Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>Java集合Map的继承关系如下图<br><a href="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/Map%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%9B%BE.PNG" data-fancybox="group" data-caption="Map的继承关系图" class="fancybox"><img alt="Map的继承关系图" title="Map的继承关系图" data-src="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/Map%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%9B%BE.PNG" class="lazyload"></a></p><h2 id="HashMap（数组-链表-红黑树）"><a href="#HashMap（数组-链表-红黑树）" class="headerlink" title="HashMap（数组+链表+红黑树）"></a>HashMap（数组+链表+红黑树）</h2><p><a href="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/HashMap.PNG" data-fancybox="group" data-caption="hashMap" class="fancybox"><img alt="hashMap" title="hashMap" data-src="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/HashMap.PNG" class="lazyload"></a></p><p>HashMap根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。</p><p>HashMap最多只允许一条记录的键为null，允许多条记录的值为null。</p><blockquote><p>HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。<strong>如果需要满足线程安全，可以用 Collections 的 synchronizedMap方法 使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</strong></p></blockquote><h3 id="Java7-的HashMap结构"><a href="#Java7-的HashMap结构" class="headerlink" title="Java7 的HashMap结构"></a>Java7 的HashMap结构</h3><p><a href="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/Java7HashMap%E7%BB%93%E6%9E%84.PNG" data-fancybox="group" data-caption="java7的HashMap结构" class="fancybox"><img alt="java7的HashMap结构" title="java7的HashMap结构" data-src="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/Java7HashMap%E7%BB%93%E6%9E%84.PNG" class="lazyload"></a></p><p>大方向上，<strong>HashMap里面是一个数组，然后数组中每个元素是一个单向链表。</strong> 上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry包含四个属性：<strong>key，value，hash值和用于单向链表的next</strong>。</p><h3 id="Java8-的HashMap结构"><a href="#Java8-的HashMap结构" class="headerlink" title="Java8 的HashMap结构"></a>Java8 的HashMap结构</h3><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以 <strong>由数组+链表+红黑树组成。</strong></p><p>根据Java7 HashMap的介绍，我们知道，查找的时候，根据 hash值 我们能够快速定位到数组的具体下标，但是之后，<strong>需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为O(n)。</strong></p><p>为了降低这部分的开销，在java8中，<strong>当链表中的元素超过了8个以后，会将链表转换为红黑树</strong>，在这些位置进行查找的时候可以降低时间复杂度为O(logN)。</p><p><a href="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/Java8%E7%9A%84HashMap%E7%BB%93%E6%9E%84.PNG" data-fancybox="group" data-caption="Java8的HashMap结构" class="fancybox"><img alt="Java8的HashMap结构" title="Java8的HashMap结构" data-src="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/Java8%E7%9A%84HashMap%E7%BB%93%E6%9E%84.PNG" class="lazyload"></a></p><h2 id="关于红黑树的介绍这里先留个坑，以后会填上"><a href="#关于红黑树的介绍这里先留个坑，以后会填上" class="headerlink" title="关于红黑树的介绍这里先留个坑，以后会填上"></a>关于红黑树的介绍这里先留个坑，以后会填上</h2><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="Segment段"><a href="#Segment段" class="headerlink" title="Segment段"></a>Segment段</h3><p>ConcurrentHashMap和HashMap思路是差不多的，但是因为它 <strong>支持并发操作</strong>，所以要复杂一些。  </p><p>整个ConcurrentHashMap由一个个Segment组成，Segment代表 “部分” 或者 “一段” 的意思，所以很多地方都会将其描述为 <strong>分段锁</strong>。</p><h3 id="线程安全（Segment继承ReentrantLock加锁）"><a href="#线程安全（Segment继承ReentrantLock加锁）" class="headerlink" title="线程安全（Segment继承ReentrantLock加锁）"></a>线程安全（Segment继承ReentrantLock加锁）</h3><blockquote><p>ReentrantLock：可重入锁</p></blockquote><p>简单理解就是，<strong>ConcurrentHashMap 是一个 Segment数组，Segment通过继承ReentrantLock来进行加锁</strong>，所以每次需要加锁的操作锁住的是一个segment，这样 <strong>只要保证每个Segment是线程安全的，也就实现了全局的线程安全</strong>。</p><p><strong>java7的ConcurrentHashMap结构：</strong></p><p><a href="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/Java7%E7%9A%84ConcurrentHashMap%E7%BB%93%E6%9E%84.PNG" data-fancybox="group" data-caption="java7的ConcurrentHashMap结构" class="fancybox"><img alt="java7的ConcurrentHashMap结构" title="java7的ConcurrentHashMap结构" data-src="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/Java7%E7%9A%84ConcurrentHashMap%E7%BB%93%E6%9E%84.PNG" class="lazyload"></a></p><p><strong>java8的ConcurrentHashMap放弃了Segment分段锁的设计，使用的是 Node数组+CAS+Synchronized 来保证线程安全</strong></p><h3 id="并行度（默认16）"><a href="#并行度（默认16）" class="headerlink" title="并行度（默认16）"></a>并行度（默认16）</h3><p>ConcurrentHashMap默认有16个Segments，所以理论上，最多可以同时支持16个线程并发写，只要它们的操作分别分布在不同的Segment上。</p><p>这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。</p><p>再具体到每个Segment内部，其实每个Segment很象之前介绍的HashMap，不过他要保证线程安全，所以处理起来要麻烦些。</p><h2 id="HashTable（线程安全）"><a href="#HashTable（线程安全）" class="headerlink" title="HashTable（线程安全）"></a>HashTable（线程安全）</h2><p>HashTable是遗留类，很多映射的常用功能与HashMap类似，不同的是它继承自Dictionary类，并且线程是安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。</p><p><strong>Hashtable 不建议在新代码中使用，不需要线程安全的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换。</strong></p><h2 id="TreeMap（可排序）"><a href="#TreeMap（可排序）" class="headerlink" title="TreeMap（可排序）"></a>TreeMap（可排序）</h2><p>TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值得升序排序，也可以指定排序得比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。</p><p><strong>如果使用排序的映射，建议使用TreeMap。</strong></p><p>在使用TreeMap时，key 必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则在运行时会抛出ClassCastException类型的异常</p><h2 id="LinkedhashMap（记录插入顺序）"><a href="#LinkedhashMap（记录插入顺序）" class="headerlink" title="LinkedhashMap（记录插入顺序）"></a>LinkedhashMap（记录插入顺序）</h2><p>LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;Map&quot;&gt;&lt;a href=&quot;#Map&quot; class=&quot;headerlink&quot; title=&quot;Map&quot;&gt;&lt;/a&gt;Map&lt;/h1&gt;&lt;p&gt;Java集合Map的继承关系如下图&lt;br&gt;&lt;a href=&quot;https://myb
      
    
    </summary>
    
    
      <category term="java基础" scheme="https://qihuang7.top/categories/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="集合" scheme="https://qihuang7.top/categories/java%E5%9F%BA%E7%A1%80/%E9%9B%86%E5%90%88/"/>
    
    
      <category term="java" scheme="https://qihuang7.top/tags/java/"/>
    
      <category term="基础" scheme="https://qihuang7.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="集合" scheme="https://qihuang7.top/tags/%E9%9B%86%E5%90%88/"/>
    
      <category term="HashMap" scheme="https://qihuang7.top/tags/HashMap/"/>
    
      <category term="红黑树" scheme="https://qihuang7.top/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Java集合：List和Set</title>
    <link href="https://qihuang7.top/2020/04/08/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%EF%BC%9AList%E5%92%8CSet/"/>
    <id>https://qihuang7.top/2020/04/08/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%EF%BC%9AList%E5%92%8CSet/</id>
    <published>2020-04-08T12:38:26.000Z</published>
    <updated>2020-04-08T17:16:40.608Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="接口继承关系和实现"><a href="#接口继承关系和实现" class="headerlink" title="接口继承关系和实现"></a>接口继承关系和实现</h1><p>集合类存放在Java.util包中，主要有3种：set（集）、list（列表包含Queue）和map（映射）</p><ol><li>Collection：是集合List、Set、Queue的最基本的接口</li><li>Iterator：迭代器，可以通过迭代器遍历集合中的数据</li><li>Map：是映射表的基础接口</li></ol><p><a href="https://img-blog.csdn.net/20180810142406579?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21ha2VsaXdlaTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" data-fancybox="group" data-caption="java集合基础关系图" class="fancybox"><img alt="java集合基础关系图" title="java集合基础关系图" data-src="https://img-blog.csdn.net/20180810142406579?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21ha2VsaXdlaTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" class="lazyload"></a></p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List是非常常用的数据类型，<strong>List是有序的Collection</strong>。List一共三个实现类：ArrayList、Vector和LinkedList</p><h3 id="ArrayList（数组）"><a href="#ArrayList（数组）" class="headerlink" title="ArrayList（数组）"></a>ArrayList（数组）</h3><p><a href="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/ArrayList.PNG" data-fancybox="group" data-caption="ArrayList" class="fancybox"><img alt="ArrayList" title="ArrayList" data-src="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/ArrayList.PNG" class="lazyload"></a></p><p>ArrayList内部是通过数组实现的，它允许对元素进行快速随机访问。</p><p>数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。</p><p>当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动，代价比较高。因此 <strong>它适合随机查找和遍历，不适合插入和删除。</strong></p><h3 id="Vector（数组实现、线程同步）"><a href="#Vector（数组实现、线程同步）" class="headerlink" title="Vector（数组实现、线程同步）"></a>Vector（数组实现、线程同步）</h3><p><a href="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/Vector.PNG" data-fancybox="group" data-caption="Vector" class="fancybox"><img alt="Vector" title="Vector" data-src="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/Vector.PNG" class="lazyload"></a></p><p>Vector也是通过数组实现的，不同的是它支持线程的同步，<strong>即某一时刻只有一个线程能写Vector，</strong> 避免多线程同时写而引起的不一致。但实现同步需要很高的花费，因此，<strong>访问它比访问ArrayList慢</strong></p><h3 id="LinkedList（链表）"><a href="#LinkedList（链表）" class="headerlink" title="LinkedList（链表）"></a>LinkedList（链表）</h3><p><a href="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/LinkedList.PNG" data-fancybox="group" data-caption="LinkedList" class="fancybox"><img alt="LinkedList" title="LinkedList" data-src="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/LinkedList.PNG" class="lazyload"></a></p><p><strong>LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除</strong>，随机访问和遍历速度比较慢。</p><p>另外，他还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，<strong>可以当作堆、栈、队列和双向队列使用。</strong></p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set注重独一无二的性质，该体系集合用于存储无序的元素，值不能重复。</p><p>对象的相等性本质是对象的hashCode（java是依据对象的内存地址计算出的此序号）判断的，<strong>如果先要让两个不同对的对象视为相等的，就必须覆盖Object的hashCode方法和equals方法。</strong></p><h3 id="HashSet（Hash表）"><a href="#HashSet（Hash表）" class="headerlink" title="HashSet（Hash表）"></a>HashSet（Hash表）</h3><p><a href="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/HashSet.PNG" data-fancybox="group" data-caption="HashSet" class="fancybox"><img alt="HashSet" title="HashSet" data-src="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/HashSet.PNG" class="lazyload"></a></p><p>哈希表存放的值是哈希值。HashSet存储元素的顺序并不是按照存入时的顺序（和List显然不同），而是按照哈希值来存的，所以取数据也是按照哈希值取得。</p><p>元素的哈希值时通过元素的hashCode方法来获取的，<strong>HashSet首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals方法。如果比较结果为true，HashSet就视为同一个元素。</strong></p><h4 id="哈希值相同且equals为false的元素时怎么存储呢？"><a href="#哈希值相同且equals为false的元素时怎么存储呢？" class="headerlink" title="哈希值相同且equals为false的元素时怎么存储呢？"></a>哈希值相同且equals为false的元素时怎么存储呢？</h4><p>就是在同样的哈希值下顺延（可以认为哈希值相同的元素放在一个哈希桶中）。也就是哈希一样的存一列。如图一表示hashCode值不相同的情况，图二表示hashCode值相同但equals值为false的情况</p><p><a href="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/hashSet%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F.PNG" data-fancybox="group" data-caption="hashSet的存储方式" class="fancybox"><img alt="hashSet的存储方式" title="hashSet的存储方式" data-src="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/hashSet%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F.PNG" class="lazyload"></a></p><p>HashSet通过hashCode值来确定元素在内存中的位置。一个hashCode位置上可以存放多个元素。</p><h3 id="TreeSet-二叉树"><a href="#TreeSet-二叉树" class="headerlink" title="TreeSet(二叉树)"></a>TreeSet(二叉树)</h3><p><a href="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/TreeSet.PNG" data-fancybox="group" data-caption="TreeSet" class="fancybox"><img alt="TreeSet" title="TreeSet" data-src="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/TreeSet.PNG" class="lazyload"></a></p><ol><li><p>TreeSet是使用二叉树的原理对新add()的对象按照指定的顺序排序（升序/降序），每增加一个对象都会进行排序，将对象插入到二叉树指定的位置</p></li><li><p>Integer和String对象都可以进行默认的TreeSet排序，而自定义类的对象是不可以的，<strong>自定义的类必须实现Comparable接口，并且覆写相应的CompareTo()函数</strong>，才可以正常使用</p></li><li><p>在覆写compare()函数时，要返回相应的值才能使TreeSet按照一定的顺序来排序</p></li><li><p>比较此对象与指定对象的顺序。如果该对象小于、等于或者大于指定对象，则分别返回负整数、零或正整数。</p></li></ol><h3 id="LinkedHashSet（HashSet-LinkedHashMap"><a href="#LinkedHashSet（HashSet-LinkedHashMap" class="headerlink" title="LinkedHashSet（HashSet+LinkedHashMap)"></a>LinkedHashSet（HashSet+LinkedHashMap)</h3><p><a href="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/LinkedHashSet.PNG" data-fancybox="group" data-caption="LinkedHashSet" class="fancybox"><img alt="LinkedHashSet" title="LinkedHashSet" data-src="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/LinkedHashSet.PNG" class="lazyload"></a></p><p>它继承了HashSet，又基于LinkedHashMap实现的。LinkedHashSet底层使用LinkedHashMap来保存所有元素。</p><p>它继承了HashSet，其所有的方法操作上跟HashSet相同，因此LinkedHashSet的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个LinkedHashMap来实现，在相关操作上与父类HashSet的操作相同，直接调用父类HashSet的方法即可。</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;接口继承关系和实现&quot;&gt;&lt;a href=&quot;#接口继承关系和实现&quot; class=&quot;headerlink&quot; title=&quot;接口继承关系和实现&quot;&gt;&lt;/a&gt;接口继承关系和实现&lt;/h1&gt;&lt;p&gt;集合类存放在Java.util包中
      
    
    </summary>
    
    
      <category term="java基础" scheme="https://qihuang7.top/categories/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="集合" scheme="https://qihuang7.top/categories/java%E5%9F%BA%E7%A1%80/%E9%9B%86%E5%90%88/"/>
    
    
      <category term="java" scheme="https://qihuang7.top/tags/java/"/>
    
      <category term="基础" scheme="https://qihuang7.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="集合" scheme="https://qihuang7.top/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>java多线程基础（八）：synchronized与锁</title>
    <link href="https://qihuang7.top/2020/04/07/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9Asynchronized%E4%B8%8E%E9%94%81/"/>
    <id>https://qihuang7.top/2020/04/07/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9Asynchronized%E4%B8%8E%E9%94%81/</id>
    <published>2020-04-07T14:18:26.000Z</published>
    <updated>2020-04-07T17:20:33.213Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="Synchronized关键字"><a href="#Synchronized关键字" class="headerlink" title="Synchronized关键字"></a>Synchronized关键字</h1><p>Java多线程的锁都是基于对象的，类锁也是对象锁<br>我们通常使用synchronized关键字来给一段代码或一个方法上锁，它通常有以下三种形式：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关键字在实例⽅法上，锁为当前实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">instanceLock</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键字在静态⽅法上，锁为当前Class对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">classLock</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键字在代码块上，锁为括号⾥⾯的对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">blockLock</span><span class="params">()</span> </span>{</span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">synchronized</span> (o) {</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="“临界区”的概念"><a href="#“临界区”的概念" class="headerlink" title="“临界区”的概念"></a>“临界区”的概念</h2><p><strong>所谓“临界区”，指的是某一块代码区域，它同一时刻只能由一个线程执行。</strong> 在上面的例子中，如果synchronized关键字在方法上，那临界区就是整个方法内部。而如果是使用synchronized代码块，那临界区就指的是代码块内部的区域。<br>下面着两个写法其实是等价的作用：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关键字在实例⽅法上，锁为当前实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">instanceLock</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键字在代码块上，锁为括号⾥⾯的对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">blockLock</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>下面这两个方法也是等价的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关键字在静态⽅法上，锁为当前Class对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">classLock</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键字在代码块上，锁为括号⾥⾯的对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">blockLock</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.getClass()) {</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h1 id="几种锁"><a href="#几种锁" class="headerlink" title="几种锁"></a>几种锁</h1><p>一个对象有四种锁状态，它们级别 <strong>由低到高</strong> 依次是：<br><strong>1. 无锁状态</strong><br><strong>2. 偏向锁状态</strong><br><strong>3. 轻量级锁状态</strong><br><strong>4. 重量级锁状态</strong>  </p><blockquote><p>几种锁都会随着竞争情况逐渐升级，锁的升级很容易发生，但是锁降级发生的条件会比较苛刻，锁降级发生在Stop The World期间，当JVM进入安全点的时候，会检查是否有闲置的锁，然后进行降级。</p></blockquote><h2 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h2><p>每个Java对象都有对象头。非数字类型会用2个字宽来存储对象头，数组则会用3个字宽来存储对象头。</p><blockquote><p>在32位处理器中，一个字宽是32位；64位虚拟机中一个字宽是64位</p></blockquote><p><strong>对象头的内容如下表：</strong></p><table><thead><tr><th>长度</th><th>内容</th><th>说明</th></tr></thead><tbody><tr><td>32/64bit</td><td>Mark Word</td><td>存储对象的hashCode或锁信息等</td></tr><tr><td>32/64bit</td><td>Class Metadata Address</td><td>存储到对象类型数据的指针</td></tr><tr><td>32/64bit</td><td>Array length</td><td>数组的长度（是数组的情况）</td></tr></tbody></table><p><strong>Mark Work 的格式：</strong></p><table><thead><tr><th>锁状态</th><th>29 bit 或 61 bit</th><th>1 bit 是否是偏向锁</th><th>2 bit 锁标志位</th></tr></thead><tbody><tr><td>无锁</td><td></td><td>0</td><td>01</td></tr><tr><td>偏向锁</td><td>线程ID</td><td>1</td><td>01</td></tr><tr><td>轻量级锁</td><td>指向栈中锁记录的指针</td><td>此时这一位不用于标识偏向锁</td><td>00</td></tr><tr><td>重量级锁</td><td>指向互斥量（重量级锁）的指针</td><td>此时这一位不用于标识偏向锁</td><td>10</td></tr><tr><td>GC标记</td><td></td><td>此时这一位不用标识偏向锁</td><td>11</td></tr></tbody></table><blockquote><p>当对象状态为偏向锁时，Mark Word 存储的是偏向的线程ID；当状态为轻量级锁时，Mark Word 存储的是指向线程栈中 Lock Record 的指针；当状态为重量级锁时，Mark Word 指向队中的monitor对象的指针</p></blockquote><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>大多数情况下 <strong>锁不仅不存在多线程竞争，而且总是由同一线程多次获得</strong>，于是引入了偏向锁</p><p>偏向锁会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不会触发同步。也就是说，<strong>偏向锁在资源无竞争情况下消除了同步语句，连CAS操作都不做了，提高了程序的运行性能。</strong></p><blockquote><p>也就是对锁置个变量，如果发现为true，代表资源无竞争，则无需再走各种加锁/解锁流程。如果为false，代表存在其他线程竞争资源，那么就会走后面的流程。</p></blockquote><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>⼀个线程在第⼀次进⼊同步块时，会在对象头和栈帧中的锁记录⾥存储锁的偏向的线程ID。当下次该线程进⼊这个同步块时，会去检查锁的Mark Word⾥⾯是不是放的⾃⼰的线程ID。</p><p>如果是，表明该线程已经获得了锁，以后该线程在进⼊和退出同步块时不需要花费CAS操作来加锁和解锁 ；如果不是，就代表有另⼀个线程来竞争这个偏向锁。这个时候会尝试使⽤CAS来替换Mark Word⾥⾯的线程ID为新线程的ID，这个时候要分两种情况： </p><ul><li>成功，表示之前的线程不存在了， Mark Word ⾥⾯的线程ID为新线程的ID，锁不会升级，仍然为偏向锁;  </li><li>失败，表示之前的线程仍然存在，那么暂停之前的线程，设置偏向锁标识为0，并设置锁标志位为00，升级为轻量级锁，会按照轻量级锁的⽅式进⾏竞争锁。</li></ul><blockquote><p>CAS：Compare and Swap<br><strong>比较并设置</strong>。⽤于在硬件层⾯上提供原⼦性操作。在 Intel 处理器中，⽐较并交换通过指令cmpxchg实现。⽐较是否和给定的数值⼀致，如果⼀致则修改，不⼀致则不修改。</p></blockquote><p>线程竞争偏向锁的过程如下：</p><p><a href="http://concurrent.redspider.group/article/02/imgs/%E5%81%8F%E5%90%91%E9%94%812.jpg" data-fancybox="group" data-caption="偏向锁操作流程" class="fancybox"><img alt="偏向锁操作流程" title="偏向锁操作流程" data-src="http://concurrent.redspider.group/article/02/imgs/%E5%81%8F%E5%90%91%E9%94%812.jpg" class="lazyload"></a></p><p>图中涉及到了lock record指针指向当前堆栈中的最近一个lock record，是轻量级锁按照 <strong>先来先服务的模式</strong> 进行了轻量级锁的加锁。</p><h3 id="撤销偏向锁"><a href="#撤销偏向锁" class="headerlink" title="撤销偏向锁"></a>撤销偏向锁</h3><p>偏向锁使用了一种 <strong>等到竞争出现才释放锁的机制</strong>，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。</p><p>偏向锁升级成轻量级锁时，会暂停拥有偏向锁的线程，重置偏向锁标识，这个过程看起来容易，实则开销还是很大的，大概的过程如下：</p><ol><li>在一个安全点（在这个时间点上没有字节码正在执行）停止拥有锁的线程。</li><li>遍历线程栈，如果存在线程记录的话，需要修复锁记录和Mark Word，使其变成无锁状态。</li><li>唤醒被停止的线程，将当前锁升级成轻量级锁。</li></ol><p>所以，如果应用程序里所有的锁通常处于竞争状态，那么偏向锁就会是一种累赘，对于这种情况，我们可以一开始就把偏向这个默认功能给关闭：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:UseBiasedLocking=false</span><br></pre></td></tr></tbody></table></figure></div><p>下图总结了偏向锁的获得和撤销：</p><p><a href="http://concurrent.redspider.group/article/02/imgs/%E5%81%8F%E5%90%91%E9%94%81.png" data-fancybox="group" data-caption="偏向锁的获得和撤销流程" class="fancybox"><img alt="偏向锁的获得和撤销流程" title="偏向锁的获得和撤销流程" data-src="http://concurrent.redspider.group/article/02/imgs/%E5%81%8F%E5%90%91%E9%94%81.png" class="lazyload"></a></p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>每个线程在不同时段获取同一把锁，即不存在锁竞争的情况，也就没有线程阻塞。针对这种情况，<strong>JVM采用轻量级锁来避免线程的阻塞与唤醒。</strong></p><h3 id="轻量级锁的加锁"><a href="#轻量级锁的加锁" class="headerlink" title="轻量级锁的加锁"></a>轻量级锁的加锁</h3><p>JVM会为每个线程在当前线程的栈帧中创建用于<strong>存储锁记录的空间</strong>，我们称为Displaced Mark Word。<strong>如果一个线程获得锁的时候发现是轻量级锁，会把锁的Mark Word复制到自己的Displaced Mark Word里面。</strong></p><p>然后线程尝试用CAS将锁的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示Mark Word已经被替换成了其他线程的锁记录，说明在与其它线程竞争锁，<strong>当前线程就尝试使用自旋来获取锁。</strong></p><blockquote><p>自旋：不断尝试去获取锁，一般用循环来实现。</p></blockquote><p>自旋是需要消耗CPU的，如果一直获取不到锁的话，那该线程就会一直处于自旋状态，白白浪费CPU资源。解决这个问题最简单的办法就是指定自旋的次数，例如让其循环10次，如果还没获取到锁就进入阻塞状态。</p><p>但是JDK采用了更聪明的方式——适应性自旋，简单来说就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。</p><p>自旋也不是一直进行下去的，如果自旋到一定程度（和JVM、操作系统相关），依然没有获取到锁，称为自旋失败，那么这个线程会阻塞。同时这个锁就会升级成重量级锁。</p><h3 id="轻量级锁的释放："><a href="#轻量级锁的释放：" class="headerlink" title="轻量级锁的释放："></a>轻量级锁的释放：</h3><p>在释放锁时，当前线程会使用CAS操作将Displaced Mark Word的内容复制回锁的Mark Word里面。如果没有发生竞争，那么这个复制的操作会成功。如果有其他线程因为自旋多次导致轻量级锁升级成了重量级锁，那么CAS操作会失败，此时会释放锁并唤醒被阻塞的线程。</p><p>下图说明加锁和释放锁的过程：</p><p><a href="http://concurrent.redspider.group/article/02/imgs/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E6%B5%81%E7%A8%8B%E5%9B%BE.png" data-fancybox="group" data-caption="轻量级锁加锁和释放锁的过程" class="fancybox"><img alt="轻量级锁加锁和释放锁的过程" title="轻量级锁加锁和释放锁的过程" data-src="http://concurrent.redspider.group/article/02/imgs/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class="lazyload"></a></p><h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>重量级锁依赖于操作系统的互斥量（mutex）实现的，而操作系统中线程间状态的转换需要相对比较长的时间，所以重量级锁效率很低，但被阻塞的线程不会消耗CPU。</p><p>前面说到，每一个对象都可以当做一个锁，当多个线程同时请求某个对象锁时，对象锁会设置几种状态用来区分请求的线程：</p><blockquote><p>Contention List：所有请求锁的线程将被首先放置到该竞争队列</p><p>Entry List：Contention List中那些有资格成为候选人的线程被移到Entry List  </p><p>Wait Set：那些调用wait方法被阻塞的线程被放置到Wait Set  </p><p>OnDeck：任何时刻最多只能有一个线程正在竞争锁，该线程称为OnDeck  </p><p>Owner：获得锁的线程称为Owner  </p><p>!Owner：释放锁的线程<br><a href="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/%E5%9B%BE%E7%89%871.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/%E5%9B%BE%E7%89%871.png" class="lazyload"></a></p></blockquote><p>当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个ObjectWaiter对象插入到Contention List的队列的队首，然后调用park函数挂起当前线程。</p><p>当线程释放锁时，会从Contention List或EntryList中挑选一个线程唤醒，被选中的线程叫做Heir presumptive即假定继承人，假定继承人被唤醒后会尝试获得锁，但synchronized是非公平的，所以假定继承人不一定能获得锁。这是因为对于重量级锁，线程先自旋尝试获得锁，这样做的目的是为了减少执行操作系统同步操作带来的开销。如果自旋不成功再进入等待队列。这对那些已经在等待队列中的线程来说，稍微显得不公平，还有一个不公平的地方是自旋线程可能会抢占了Ready线程的锁。</p><p>线程获得锁后调用Object.wait方法，则会将线程加入到WaitSet中，当被Object.notify唤醒后，会将线程从WaitSet移动到Contention List或EntryList中去。需要注意的是，当调用一个锁对象的wait或notify方法时，<strong>如果当前锁的状态是偏向锁或轻量级锁则会先膨胀成重量级锁。</strong></p><h2 id="总结锁的升级流程"><a href="#总结锁的升级流程" class="headerlink" title="总结锁的升级流程"></a>总结锁的升级流程</h2><p>每一个线程在准备获取共享资源时：<br>第一步，检查Mark Word里面是不是放的自己的线程Id，如果是，表示当前线程是<strong>处于“偏向锁”</strong></p><p>第二步，如果Mark Word不是自己的线程Id，<strong>锁升级</strong>，这时候，用CAS来执行切换，新的线程根据Mark Word里面现有的线程Id，通知之前线程暂停，之前线程将Mark Word的内容置为空。</p><p>第三步，两个线程都把锁对象的HashCode复制到自己新建的用于存储锁的记录空间，接着就开始通过CAS操作，把锁对象的Mark Word的内容修改为自己新建的记录空间的地址的方式竞争Mark Word。</p><p>第四步，第三步中成功执行CAS的获得资源，失败的则进入自旋。</p><p>第五步，自旋的线程在自旋过程中，成功获得资源（即之前获得的资源的线程执行完成并释放了共享资源），则整个状态依然处于轻量级锁的状态，如果自旋失败</p><p>第六步，<strong>进入重量级锁的状态</strong>，这个时候，自旋的线程进行阻塞，等待之前的线程执行完成并唤醒自己。</p><h2 id="各种锁的优缺点对比"><a href="#各种锁的优缺点对比" class="headerlink" title="各种锁的优缺点对比"></a>各种锁的优缺点对比</h2><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>使用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td><td>适用于只有一个线程访问同步块场景。</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，提高了程序的响应速度。</td><td>如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td><td>追求响应时间。同步块执行速度非常快。</td></tr><tr><td>重量级锁</td><td>线程竞争不使用自旋，不会消耗CPU。</td><td>线程阻塞，响应时间缓慢。</td><td>追求吞吐量。同步块执行速度较长。</td></tr></tbody></table></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;Synchronized关键字&quot;&gt;&lt;a href=&quot;#Synchronized关键字&quot; class=&quot;headerlink&quot; title=&quot;Synchronized关键字&quot;&gt;&lt;/a&gt;Synchronized关键字&lt;
      
    
    </summary>
    
    
      <category term="java基础" scheme="https://qihuang7.top/categories/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="https://qihuang7.top/categories/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://qihuang7.top/tags/java/"/>
    
      <category term="基础" scheme="https://qihuang7.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="锁" scheme="https://qihuang7.top/tags/%E9%94%81/"/>
    
      <category term="synchronized" scheme="https://qihuang7.top/tags/synchronized/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：有效的括号</title>
    <link href="https://qihuang7.top/2020/04/07/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>https://qihuang7.top/2020/04/07/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</id>
    <published>2020-04-07T13:37:29.000Z</published>
    <updated>2020-04-07T16:55:36.586Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h1><p><strong>题目：</strong> 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p>注意空字符串可被认为是有效字符串。</p><p>示例 1:</p><blockquote><p>输入: “()”<br>输出: true</p></blockquote><p>示例 2:</p><blockquote><p>输入: “()[]{}”<br>输出: true</p></blockquote><p>示例 3:</p><blockquote><p>输入: “(]”<br>输出: false</p></blockquote><p>示例 4:</p><blockquote><p>输入: “([)]”<br>输出: false</p></blockquote><p>示例 5:</p><blockquote><p>输入: “{[]}”<br>输出: true</p></blockquote><h2 id="官方题解：栈"><a href="#官方题解：栈" class="headerlink" title="官方题解：栈"></a>官方题解：栈</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>关于有效括号表达式的一个有趣属性是有效表达式的子表达式也应该是有效表达式。（不是每个子表达式）例如</p><p><a href="https://pic.leetcode-cn.com/Figures/20/20-Valid-Parentheses-Recursive-Property.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://pic.leetcode-cn.com/Figures/20/20-Valid-Parentheses-Recursive-Property.png" class="lazyload"></a></p><p>此外，如果仔细查看上述结构，颜色标识的单元格将标记开闭的括号对。整个表达式是有效的，而它的子表达式本身也是有效的。这为问题提供了一种递归结构。例如，考虑上图中两个绿色括号内的表达式。开括号位于索引 1，相应闭括号位于索引 6。</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ol><li>初始化栈 S。</li><li>一次处理表达式的每个括号。</li><li>如果遇到开括号，我们只需将其推到栈上即可。这意味着我们将稍后处理它，让我们简单地转到前面的 子表达式。</li><li>如果我们遇到一个闭括号，那么我们检查栈顶的元素。如果栈顶的元素是一个 相同类型的 左括号，那么我们将它从栈中弹出并继续处理。否则，这意味着表达式无效。</li><li>如果到最后我们剩下的栈中仍然有元素，那么这意味着表达式无效。</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">boolean</span> valid = solution.isValid(<span class="string">"{{(())}[]}"</span>);</span><br><span class="line">        System.out.println(valid);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> HashMap<character, character> mappings;</character,></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.mappings = <span class="keyword">new</span> HashMap<character, character>();</character,></span><br><span class="line">        <span class="keyword">this</span>.mappings.put(<span class="string">')'</span>, <span class="string">'('</span>);</span><br><span class="line">        <span class="keyword">this</span>.mappings.put(<span class="string">'}'</span>, <span class="string">'{'</span>);</span><br><span class="line">        <span class="keyword">this</span>.mappings.put(<span class="string">']'</span>, <span class="string">'['</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>{</span><br><span class="line">        Stack<character> stack = <span class="keyword">new</span> Stack<character>();</character></character></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < s.length(); i++) {</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.mappings.containsKey(c)) {</span><br><span class="line">                <span class="keyword">char</span> topElement = stack.empty() ? <span class="string">'#'</span> : stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (topElement != <span class="keyword">this</span>.mappings.get(c)) {</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                stack.push(c);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(n)，因为我们一次只遍历给定的字符串中的一个字符并在栈上进行 O(1) 的推入和弹出操作。</li><li>空间复杂度：O(n)，当我们将所有的开括号都推到栈上时以及在最糟糕的情况下，我们最终要把所有括号推到栈上。例如 ((((((((((。</li></ul></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;20-有效的括号&quot;&gt;&lt;a href=&quot;#20-有效的括号&quot; class=&quot;headerlink&quot; title=&quot;20. 有效的括号&quot;&gt;&lt;/a&gt;20. 有效的括号&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;题目：&lt;/strong
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://qihuang7.top/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://qihuang7.top/tags/leetcode/"/>
    
      <category term="栈" scheme="https://qihuang7.top/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>java多线程基础（七）：volatile关键字</title>
    <link href="https://qihuang7.top/2020/04/07/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9Avolatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://qihuang7.top/2020/04/07/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9Avolatile%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2020-04-06T16:00:26.000Z</published>
    <updated>2020-04-10T07:45:42.123Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="第七章-volatile关键字"><a href="#第七章-volatile关键字" class="headerlink" title="第七章 volatile关键字"></a>第七章 volatile关键字</h1><h2 id="volatile的内存语义"><a href="#volatile的内存语义" class="headerlink" title="volatile的内存语义"></a>volatile的内存语义</h2><p>volatile关键字主要有以下两个功能：</p><ul><li>保证变量的 <strong>内存可见性</strong></li><li><strong>禁止</strong> volatile 变量与普通变量 <strong>重排序</strong></li></ul><h3 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h3><p>示例代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>{</span><br><span class="line">        a = <span class="number">1</span>; <span class="comment">// step 1</span></span><br><span class="line">        flag = <span class="keyword">true</span>; <span class="comment">// step 2</span></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (flag) { <span class="comment">// step 3</span></span><br><span class="line">            System.out.println(a); <span class="comment">// step 4</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>在这段代码里，我们使用 volatile 关键字修饰了一个 boolean 类型的变量 flag</p><blockquote><p><strong>所谓内存可见性，指的时当一个线程对 volatile 修饰的变量进行写操作（比如step2）时，JMM 会立即把该线程对应的本地内存中的共享变量的值刷新到主内存；当一个线程对 volatile 修饰的变量进行读操作（比如step3）时，JMM会立即把该线程对应的本地内存置为无效，从主内存中读取共享变量的值。</strong></p></blockquote><p>假设在时间线上，线程A先执行 writer 方法，线程B后执行 reader 方法。那么必然会有下图：<br><a href="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/volatile.PNG" data-fancybox="group" data-caption="程序执行步骤与主内存变化" class="fancybox"><img alt="程序执行步骤与主内存变化" title="程序执行步骤与主内存变化" data-src="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/volatile.PNG" class="lazyload"></a></p><p>如果 flag变量 没有用 volatile 修饰，在step2的变量就不会立即更新到主内存，线程B 也不会拿到最新的值，仍然使用B本地内存缓存的变量值 a = 0,flag = false.</p><h3 id="禁止重排序"><a href="#禁止重排序" class="headerlink" title="禁止重排序"></a>禁止重排序</h3><p><strong>在旧的java内存模型中，是允许 volatile变量 与普通变量重排序的。</strong> 上面的案例就可能会被重排序成下列时序来执行：  </p><ol><li>线程A写volatile变量，step2，设置flag 为true；  </li><li>线程B读同一个volatile，step3，读取到flag 为true； </li><li>线程B读普通变量，step4，读取到a = 0；  </li><li>线程A修改普通变量，step1，设置a = 1;</li></ol><p>可见，如果 volatile变量与普通变量发生了重排序，虽然 volatile变量能保证内存可见性，也可能导致普通变量读取错误。</p><p>为了提供一种比锁更轻量级的线程间的通信机制，JSR-133专家组决定增强 volatile的内存语义：<strong>严格限制编译器和处理器对volatile变量与普通变量的重排序。</strong></p><h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><h4 id="JVM是怎么限制处理器的重排序的呢？"><a href="#JVM是怎么限制处理器的重排序的呢？" class="headerlink" title="JVM是怎么限制处理器的重排序的呢？"></a>JVM是怎么限制处理器的重排序的呢？</h4><p>它是通过 <strong>内存屏障</strong> 来实现的</p><blockquote><p>硬件层面，内存屏障分两种：<strong>读屏障（Load Barrier）和写屏障（Store Barrier）</strong>。</p></blockquote><p><strong>内存屏障有两个作用：</strong>  </p><p><strong>1.阻止屏障两侧的指令重排序；</strong><br><strong>2.强制把写缓冲区/高速缓存中的脏数据等写回主内存，或者让缓存中相应的数据失效。</strong></p><p>编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。编译器选择了一个比较保守的<strong>JMM内存屏障插入策略：</strong></p><ul><li>在每个 volatile写操作 前 插入一个 StoreStore屏障；</li><li>在每个 volatile写操作 后 插入一个 StoreLoad屏障；</li><li>在每个 volatile读操作 后 插入一个 LoadLoad屏障；</li><li>在每个 volatile读操作 后 插入一个 LoadStore屏障。</li></ul><p>示意图：<br><a href="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/JMM%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E6%8F%92%E2%BC%8A%E7%AD%96%E7%95%A5.PNG" data-fancybox="group" data-caption="JMM内存屏障插入策略" class="fancybox"><img alt="JMM内存屏障插入策略" title="JMM内存屏障插入策略" data-src="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/JMM%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E6%8F%92%E2%BC%8A%E7%AD%96%E7%95%A5.PNG" class="lazyload"></a></p><p><strong>volatile与普通变量的重排序规则：</strong><br><strong>1. 如果第⼀个操作是volatile读，那⽆论第⼆个操作是什么，都不能重排序；</strong><br><strong>2. 如果第⼆个操作是volatile写，那⽆论第⼀个操作是什么，都不能重排序；</strong><br><strong>3. 如果第⼀个操作是volatile写，第⼆个操作是volatile读，那不能重排序。</strong>  </p><blockquote><p>在案例中step 1，是普通变量的写，step2是volatile变量的写，那符合第2个规则，这两个steps不能重排序。⽽step3是volatile变量读，step4是普通变量读，符合第1个规则，同样不能重排序。</p></blockquote><p>如果是第一个操作是普通变量读，第二个操作是volatile变量读，那是可以重排序的：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明变量</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>; <span class="comment">// 声明普通变量</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">// 声明volatile变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下两个变量的读操作是可以重排序的</span></span><br><span class="line"><span class="keyword">int</span> i = a; <span class="comment">// 普通变量读</span></span><br><span class="line"><span class="keyword">boolean</span> j = flag; <span class="comment">// volatile变量读</span></span><br></pre></td></tr></tbody></table></figure></div><h2 id="volatile的用途"><a href="#volatile的用途" class="headerlink" title="volatile的用途"></a>volatile的用途</h2><p>在保存内存可见性这一点上，volatile有着与锁相同的内存语义，所以 <strong>可以作为一个“轻量级”的锁来使用</strong> 。但由于volatile仅仅保证对单个volatile变量的读/写具有原子性，而锁可以保证整个临界区代码的执行具有原子性。所以 <strong>在功能上，锁比volatile更强大； 在性能上，volatile更有优势</strong></p><h3 id="单例模式中volatile的应用"><a href="#单例模式中volatile的应用" class="headerlink" title="单例模式中volatile的应用"></a>单例模式中volatile的应用</h3><p><strong>“双重锁检查”</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance; </span><br><span class="line">    <span class="comment">// 双重锁检验</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) { <span class="comment">// 第7⾏</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>{</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton(); </span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;第七章-volatile关键字&quot;&gt;&lt;a href=&quot;#第七章-volatile关键字&quot; class=&quot;headerlink&quot; title=&quot;第七章 volatile关键字&quot;&gt;&lt;/a&gt;第七章 volatile关键字&lt;
      
    
    </summary>
    
    
      <category term="java基础" scheme="https://qihuang7.top/categories/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="https://qihuang7.top/categories/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://qihuang7.top/tags/java/"/>
    
      <category term="基础" scheme="https://qihuang7.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="https://qihuang7.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="volatile" scheme="https://qihuang7.top/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>java多线程基础（六）：重排序与happens-before</title>
    <link href="https://qihuang7.top/2020/04/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E9%87%8D%E6%8E%92%E5%BA%8F%E4%B8%8Ehappens-before/"/>
    <id>https://qihuang7.top/2020/04/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E9%87%8D%E6%8E%92%E5%BA%8F%E4%B8%8Ehappens-before/</id>
    <published>2020-04-06T15:45:26.000Z</published>
    <updated>2020-04-06T16:01:17.512Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="第六章-重排序与happens-before"><a href="#第六章-重排序与happens-before" class="headerlink" title="第六章 重排序与happens-before"></a>第六章 重排序与happens-before</h1><h2 id="什么是重排序？"><a href="#什么是重排序？" class="headerlink" title="什么是重排序？"></a>什么是重排序？</h2><p><strong>为优化程序性能，对原有的指令执行顺序进行优化重新排序。</strong> </p><blockquote><p>每一个指令都会包含多个步骤，每个步骤可能使用不同的硬件。因此 <strong>流水线技术</strong> 产生了，它的原理是 <strong>指令1还没有执行完，就可以开始执行指令2，而不用等到指令1执行结束之后再执行指令2，这样就大大提高了效率</strong></p></blockquote><p>流水线技术最害怕 <strong>中断</strong>，恢复中断的代价是比较大的，<strong>指令重排就是减少中断的一种技术。</strong></p><p>指令重排一般分为以下三种：</p><ul><li><strong>编译器优化重排</strong> </li><li><strong>指令并行重排</strong></li><li><strong>内存系统重排</strong></li></ul><h2 id="顺序一致性模型"><a href="#顺序一致性模型" class="headerlink" title="顺序一致性模型"></a>顺序一致性模型</h2><p>顺序一致性模型是一个 <strong>理论参考模型</strong> ，它为程序员提供了 <strong>极强的内存可见性保证。</strong></p><h3 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h3><p><strong>内存可见性，指的是线程之间的可见性，当一个线程修改了共享变量时，另一个线程可以读取到这个修改后的值。</strong></p><h3 id="数据竞争与顺序一致性"><a href="#数据竞争与顺序一致性" class="headerlink" title="数据竞争与顺序一致性"></a>数据竞争与顺序一致性</h3><p>当程序未正确同步的时候，就可能存在数据竞争，运行的结果往往充满了不确定性。</p><blockquote><p>数据竞争：在一个线程中写一个变量，另一个线程读同一个变量，并且写和读没有通过同步来排序。</p></blockquote><h3 id="顺序一致性模型有两大特性："><a href="#顺序一致性模型有两大特性：" class="headerlink" title="顺序一致性模型有两大特性："></a>顺序一致性模型有两大特性：</h3><ul><li>一个线程中的所有操作必须按照程序的顺序来执行</li><li>每个操作必须是原子性的，且立刻对所有线程可见</li></ul><p>假设有两个线程 A 和 B 并发执行，线程 A 有3个操作，它们在程序中的顺序是 A1->A2->A3 ，线程 B 也有3个操作，B1->B2->B3</p><p>假设 <strong>正确使用了同步</strong> ，A 线程的3个操作执行后释放锁，B线程获取同一个锁。那么在顺序一致性模型中的执行效果如下所示：</p><p><strong>A1–>A2–>A3–>B1–>B2–>B3</strong></p><p>假设 <strong>没有使用同步</strong> ，那么在顺序一致性模型中的执行效果如下所示：</p><p><strong>B1–>A1–>A2–>B2–>A3–>B3</strong></p><h2 id="happens-before规则"><a href="#happens-before规则" class="headerlink" title="happens-before规则"></a>happens-before规则</h2><p>只要程序员在写代码时遵循 happens-before 规则，JVM就能保证指令在多线程之间的顺序性符合程序员的预期</p><p><strong>天然的happens-before关系：</strong></p><ul><li><strong>程序顺序规则</strong>：⼀个线程中的每⼀个操作，happens-before于该线程中的任意后续操作</li><li><strong>监视器锁规则</strong>：对⼀个锁的解锁，happens-before于随后对这个锁的加锁</li><li><strong>volatile变量规则</strong>：对⼀个volatile域的写，happens-before于任意后续对这个 volatile 域的读。</li><li><strong>传递性</strong>：如果A happens-before B，且B happens-before C，那么A happensbefore C。</li><li><strong>start规则</strong>：如果线程A执⾏操作ThreadB.start()启动线程B，那么A线程的 ThreadB.start（）操作happens-before于线程B中的任意操作</li><li><strong>join规则</strong>：如果线程A执⾏操作ThreadB.join（）并成功返回，那么线程B中的任意操作 happens-before 于线程A从ThreadB.join()操作成功返回。</li></ul></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;第六章-重排序与happens-before&quot;&gt;&lt;a href=&quot;#第六章-重排序与happens-before&quot; class=&quot;headerlink&quot; title=&quot;第六章 重排序与happens-before&quot;
      
    
    </summary>
    
    
      <category term="java基础" scheme="https://qihuang7.top/categories/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="https://qihuang7.top/categories/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://qihuang7.top/tags/java/"/>
    
      <category term="基础" scheme="https://qihuang7.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="https://qihuang7.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：合并排序的数组</title>
    <link href="https://qihuang7.top/2020/04/06/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84/"/>
    <id>https://qihuang7.top/2020/04/06/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84/</id>
    <published>2020-04-05T16:43:29.000Z</published>
    <updated>2020-04-05T16:44:06.528Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="面试题10-01-合并排序的数组"><a href="#面试题10-01-合并排序的数组" class="headerlink" title="面试题10.01 合并排序的数组"></a>面试题10.01 合并排序的数组</h1><p>给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。</p><p>初始化 A 和 B 的元素数量分别为 m 和 n。</p><p><strong>示例:</strong></p><blockquote><p>输入:<br>A = [1,2,3,0,0,0], m = 3<br>B = [2,5,6],       n = 3<br>输出: [1,2,2,3,5,6]</p></blockquote><p>说明:</p><blockquote><p>A.length == n + m</p></blockquote><p><strong>暴力解法：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> m, <span class="keyword">int</span>[] B, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m;i<m+n;i++){< span><br><span class="line">            A[i] = B[j++];</span><br><span class="line">        }</span><br><span class="line">        Arrays.sort(A);</span><br><span class="line">    }</span><br><span class="line">}</span><br></m+n;i++){<></span></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;面试题10-01-合并排序的数组&quot;&gt;&lt;a href=&quot;#面试题10-01-合并排序的数组&quot; class=&quot;headerlink&quot; title=&quot;面试题10.01 合并排序的数组&quot;&gt;&lt;/a&gt;面试题10.01 合并排序
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://qihuang7.top/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://qihuang7.top/tags/leetcode/"/>
    
      <category term="数组" scheme="https://qihuang7.top/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="排序" scheme="https://qihuang7.top/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>java多线程基础（五）：线程间的通信</title>
    <link href="https://qihuang7.top/2020/04/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/"/>
    <id>https://qihuang7.top/2020/04/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/</id>
    <published>2020-04-05T12:54:26.000Z</published>
    <updated>2020-04-05T12:54:38.791Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="第五章-Java线程间的通信"><a href="#第五章-Java线程间的通信" class="headerlink" title="第五章 Java线程间的通信"></a>第五章 Java线程间的通信</h1><h2 id="锁与同步"><a href="#锁与同步" class="headerlink" title="锁与同步"></a>锁与同步</h2><p>锁的概念都是 <strong>基于对象</strong> 的，所以又称它为“对象锁”。</p><p><strong>一个锁同一时间只能被一个线程持有。</strong> </p><p><strong>线程同步是线程之间按照一定的顺序执行</strong></p><blockquote><p>假如我们现在有2位正在抄暑假作业答案的同学：线程A和线程B。当他们正在抄的时候，⽼师突然来修改了⼀些答案，可能A和B最后写出的暑假作业就不⼀样。我们为了A,B能写出2本相同的暑假作业，我们就需要让⽼师先修改答案，然后A，B同学再抄。或者A，B同学先抄完，⽼师再修改答案。这就是线程A，线程B的线程同步。</p></blockquote><p>首先看一个无锁的程序：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoneLock</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">100</span>; i++) {</span><br><span class="line">                System.out.println(<span class="string">"Thread A "</span> + i);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">100</span>; i++) {</span><br><span class="line">                System.out.println(<span class="string">"Thread B "</span> + i);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadA()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadB()).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*执行结果：线程 A 和线程 B 各⾃独⽴⼯作，输出⾃⼰的打印值。</span></span><br><span class="line"><span class="comment">    ....</span></span><br><span class="line"><span class="comment">    Thread A 48</span></span><br><span class="line"><span class="comment">    Thread A 49</span></span><br><span class="line"><span class="comment">    Thread B 0</span></span><br><span class="line"><span class="comment">    Thread A 50</span></span><br><span class="line"><span class="comment">    Thread B 1</span></span><br><span class="line"><span class="comment">    Thread A 51</span></span><br><span class="line"><span class="comment">    Thread A 52</span></span><br><span class="line"><span class="comment">    ....</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure></div><p>如果需要 <strong>A先执行完之后再由B去执行</strong> 该怎么做？<br>最简单的⽅式就是使⽤⼀个“对象锁”：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectLock</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">100</span>; i++) {</span><br><span class="line">                    System.out.println(<span class="string">"Thread A "</span> + i);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">100</span>; i++) {</span><br><span class="line">                    System.out.println(<span class="string">"Thread B "</span> + i);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadA()).start();</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadB()).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>线程B 就会等线程A 执行完成后释放 lock ,线程B 才能获得锁 lock 。</p><blockquote><p>这⾥在主线程⾥使⽤ sleep⽅法 睡眠了10毫秒，是为了防⽌线程B先得到锁。 因为如果同时 start，线程 A 和线程 B 都是出于就绪状态，操作系统可能会先让 B 运行。这样就会先输出 B 的内容，然后 B 执行完成之后⾃动释放锁，线程 A 再执行。</p></blockquote><h2 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h2><p>多线程的等待/通知机制是基于 Object 类的 wait() 方法和 notify() ,notifyAll() 方法来实现的</p><blockquote><p>notify()方法会随机叫醒一个正在等待的线程  ，notifyAll() 会叫醒所有正在等待的线程。</p></blockquote><p>假如 线程A 现在持有一个 锁lock 并开始执行，它可以使用 lock.wait() 让自己进入等待状态，lock锁 被释放。这时，线程B 获得了 lock锁 并开始执行，在某个时刻使用 lock.notify()，通知等待状态的 A，但是 线程B 并没有释放锁，除非 B 使用 lock.wait() 或者B 执行结束自行释放锁，A 才能得到 lock锁</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitAndNotify</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">5</span>; i++) {</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        System.out.println(<span class="string">"ThreadA: "</span> + i);</span><br><span class="line">                        lock.notify();</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                lock.notify();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">5</span>; i++) {</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        System.out.println(<span class="string">"ThreadB: "</span> + i);</span><br><span class="line">                        lock.notify();</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                lock.notify();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadA()).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadB()).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">    ThreadA: 0</span></span><br><span class="line"><span class="comment">    ThreadB: 0</span></span><br><span class="line"><span class="comment">    ThreadA: 1</span></span><br><span class="line"><span class="comment">    ThreadB: 1</span></span><br><span class="line"><span class="comment">    ThreadA: 2</span></span><br><span class="line"><span class="comment">    ThreadB: 2</span></span><br><span class="line"><span class="comment">    ThreadA: 3</span></span><br><span class="line"><span class="comment">    ThreadB: 3</span></span><br><span class="line"><span class="comment">    ThreadA: 4</span></span><br><span class="line"><span class="comment">    ThreadB: 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure></div><p>线程A 和线程B 首先打印出自己需要的东西，然后使用 notify() 方法叫醒另一个正在等待的线程，然后自己使用 wait() 方法陷入等待并释放lock锁。</p><blockquote><p><strong>等待/通知机制使用的是使用同⼀个对象</strong></p></blockquote><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>基于 volatile 关键字的⾃⼰实现的信号量通信。</p><blockquote><p>volitile关键字能够 <strong>保证内存的可⻅性</strong>，如果⽤volitile关键字声明了⼀个变量，在⼀个线程⾥⾯改变了这个变量的值，那其它线程是 <strong>⽴⻢可⻅更改后的值</strong> 的。</p></blockquote><p>需求：让 线程A 输出0，然后 线程B 输出1，再然后 线程A 输出2…以此类推。</p><p>代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Signal</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> signal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">while</span> (signal < <span class="number">5</span>) {</span><br><span class="line">                <span class="keyword">if</span> (signal % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">                    System.out.println(<span class="string">"threadA: "</span> + signal);</span><br><span class="line">                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">                        signal++;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">while</span> (signal < <span class="number">5</span>) {</span><br><span class="line">                <span class="keyword">if</span> (signal % <span class="number">2</span> == <span class="number">1</span>) {</span><br><span class="line">                    System.out.println(<span class="string">"threadB: "</span> + signal);</span><br><span class="line">                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">                        signal = signal + <span class="number">1</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadA()).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadB()).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">    threadA: 0</span></span><br><span class="line"><span class="comment">    threadB: 1</span></span><br><span class="line"><span class="comment">    threadA: 2</span></span><br><span class="line"><span class="comment">    threadB: 3</span></span><br><span class="line"><span class="comment">    threadA: 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure></div><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道是基于“管道流”的通信方式。JDK提供了 Pipedwriter、 PipedReader、 PipedOutputStream、 PipedInputStream。其中，前面两个是基于字符的，后面两个是基于字节流的。</p><p>示例代码：基于字符的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pipe</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> PipedReader reader;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ReaderThread</span><span class="params">(PipedReader reader)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.reader = reader;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            System.out.println(<span class="string">"this is reader"</span>);</span><br><span class="line">            <span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">while</span> ((receive = reader.read()) != -<span class="number">1</span>) {</span><br><span class="line">                    System.out.print((<span class="keyword">char</span>) receive);</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriterThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> PipedWriter writer;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WriterThread</span><span class="params">(PipedWriter writer)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.writer = writer;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            System.out.println(<span class="string">"this is writer"</span>);</span><br><span class="line">            <span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                writer.write(<span class="string">"test"</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    writer.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>{</span><br><span class="line">        PipedWriter writer = <span class="keyword">new</span> PipedWriter();</span><br><span class="line">        PipedReader reader = <span class="keyword">new</span> PipedReader();</span><br><span class="line">        writer.connect(reader); <span class="comment">// 这⾥注意⼀定要连接，才能通信</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ReaderThread(reader)).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> WriterThread(writer)).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">        this is reader</span></span><br><span class="line"><span class="comment">        this is writer</span></span><br><span class="line"><span class="comment">        test</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure></div><p>执行流程：</p><ol><li>线程ReaderThread开始执行， </li><li>线程ReaderThread使用管道reader.read()进⼊“阻塞”， </li><li>线程WriterThread开始执行， </li><li>线程WriterThread⽤writer.write(“test”)往管道写⼊字符串， </li><li>线程WriterThread使⽤writer.close()结束管道写⼊，并执行完毕， </li><li>线程ReaderThread接受到管道输出的字符串并打印， </li><li>线程ReaderThread执行完毕。</li></ol><blockquote><p>管道通信的应用场景：多半与I/O流相关。当我们一个线程需要另一个线程发送一个信息（比如字符串）或者文件等等时，就需要使用管道通信了。</p></blockquote><h2 id="其他通信"><a href="#其他通信" class="headerlink" title="其他通信"></a>其他通信</h2><ul><li><strong>join方法：</strong> 如果主线程想等待子线程执行完毕后 <strong>获得子线程中处理完的某个数据</strong>，就要用到 join方法 了</li><li><strong>sleep方法：sleep方法时不会释放当前的锁，容易死锁，而wait方法会。sleep方法必须指定时间。wait方法必须放在同步块或同步方法中,而sleep可以在任意位置。</strong></li><li>ThreadLocal类：它为每个线程都创建⼀个副本，每个线程可以访问⾃⼰内部的副本变量。</li><li>InheritableThreadLocal：它不仅仅是当前线程可以存取副本值，⽽且它的⼦线程也可以存取这个副本值。</li></ul></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;第五章-Java线程间的通信&quot;&gt;&lt;a href=&quot;#第五章-Java线程间的通信&quot; class=&quot;headerlink&quot; title=&quot;第五章 Java线程间的通信&quot;&gt;&lt;/a&gt;第五章 Java线程间的通信&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="java基础" scheme="https://qihuang7.top/categories/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="https://qihuang7.top/categories/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://qihuang7.top/tags/java/"/>
    
      <category term="基础" scheme="https://qihuang7.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="https://qihuang7.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="通信" scheme="https://qihuang7.top/tags/%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>Spring基础（三）：IOC与AOP基于注解方式</title>
    <link href="https://qihuang7.top/2020/04/05/%E6%A1%86%E6%9E%B6/Spring%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AIOC%E4%B8%8EAOP%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F/"/>
    <id>https://qihuang7.top/2020/04/05/%E6%A1%86%E6%9E%B6/Spring%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AIOC%E4%B8%8EAOP%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F/</id>
    <published>2020-04-05T09:10:39.000Z</published>
    <updated>2020-04-05T09:11:56.263Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="IOC与AOP基于注解"><a href="#IOC与AOP基于注解" class="headerlink" title="IOC与AOP基于注解"></a>IOC与AOP基于注解</h1><p>首先修改配置文件applicationContext.xml，表示告诉Spring要使用注解的方式进行配置<br><strong>一般情况两个配置不一起使用。</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><!-- 扫描含有注解（@Component 等）类，注入注解自动生效 --></span></span><br><span class="line"><span class="tag"><<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">" "</span>></span></span><br><span class="line"><span class="comment"><!--只在xml和注解（注入）混合使用时，使注入注解生效。--></span></span><br><span class="line"><span class="tag"><<span class="name">context:annotation-config</span>></span></span><br></pre></td></tr></tbody></table></figure></div><h2 id="IOC注解"><a href="#IOC注解" class="headerlink" title="IOC注解"></a>IOC注解</h2><ol><li>@Component：组件，用于实现ioc控制反转,属性value用于实现对象id定义</li><li>@Scope：作用域，用于实现单例，多例，request，session等的配置</li><li><strong>@Controller：</strong> 专门用于controller层的注解</li><li><strong>@Service：</strong> 专门用于service层的注解</li><li><strong>@Repository：</strong> 专门用于DAO持久层的注解</li><li>@Resouce：注解会转而查找和属性类型相匹配Bean组件并注入。</li><li><strong>@Autowired：</strong> 自动注入</li></ol><h2 id="AOP注解"><a href="#AOP注解" class="headerlink" title="AOP注解"></a>AOP注解</h2><p>首先要在配置文件中开启对aop注解的支持</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><!-- 开启 spring 对注解 AOP 的支持 --></span> </span><br><span class="line"><span class="tag"><<span class="name">aop:aspectj-autoproxy</span>/></span></span><br></pre></td></tr></tbody></table></figure></div><ol><li>@Aaspet：表示当前类是一个切面类</li><li>@AfterReturning：后置通知，属性value用于指定切入点表达式</li><li>@AfterThrowing：异常通知</li><li>@After：最终通知</li><li>@Around：环绕通知<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 环绕通知 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="meta">@Around</span>(<span class="string">"execution(* com.dustdawn.service.impl.*.*(..))"</span>) </span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transactionAround</span><span class="params">(ProceedingJoinPoint pjp)</span> </span>{ </span><br><span class="line">    <span class="comment">//定义返回值 </span></span><br><span class="line">    Object rtValue = <span class="keyword">null</span>; </span><br><span class="line">    <span class="keyword">try</span> { </span><br><span class="line">        <span class="comment">//获取方法执行所需的参数 </span></span><br><span class="line">        Object[] args = pjp.getArgs(); </span><br><span class="line">        <span class="comment">//前置通知：开启事务 </span></span><br><span class="line">        beginTransaction(); </span><br><span class="line">        <span class="comment">//执行方法 </span></span><br><span class="line">        rtValue = pjp.proceed(args); </span><br><span class="line">        <span class="comment">//后置通知：提交事务 </span></span><br><span class="line">        commit(); </span><br><span class="line">    }<span class="keyword">catch</span>(Throwable e) { </span><br><span class="line">        <span class="comment">//异常通知：回滚事务 </span></span><br><span class="line">        rollback(); </span><br><span class="line">        e.printStackTrace(); </span><br><span class="line">    }<span class="keyword">finally</span> { </span><br><span class="line">        <span class="comment">//最终通知：释放资源 </span></span><br><span class="line">        release(); </span><br><span class="line">    } </span><br><span class="line">    <span class="keyword">return</span> rtValue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></li><li>@Pointcut：用于指定切入点表达式，使用方式：<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* com.xxx.service.impl.*.*(..))"</span>) </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pt1</span><span class="params">()</span> </span>{} </span><br><span class="line"></span><br><span class="line"><span class="meta">@Around</span>(<span class="string">"pt1()"</span>)   <span class="comment">//注意：千万别忘了写括号 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transactionAround</span><span class="params">(ProceedingJoinPoint pjp)</span> </span>{ </span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></li></ol></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;IOC与AOP基于注解&quot;&gt;&lt;a href=&quot;#IOC与AOP基于注解&quot; class=&quot;headerlink&quot; title=&quot;IOC与AOP基于注解&quot;&gt;&lt;/a&gt;IOC与AOP基于注解&lt;/h1&gt;&lt;p&gt;首先修改配置文件a
      
    
    </summary>
    
    
      <category term="框架" scheme="https://qihuang7.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="spring" scheme="https://qihuang7.top/categories/%E6%A1%86%E6%9E%B6/spring/"/>
    
    
      <category term="基础" scheme="https://qihuang7.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="SSM" scheme="https://qihuang7.top/tags/SSM/"/>
    
      <category term="spring" scheme="https://qihuang7.top/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：数组中重复的数字</title>
    <link href="https://qihuang7.top/2020/04/04/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://qihuang7.top/2020/04/04/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2020-04-04T15:30:29.000Z</published>
    <updated>2020-04-04T15:30:33.300Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="面试题03：数组中重复的数字"><a href="#面试题03：数组中重复的数字" class="headerlink" title="面试题03：数组中重复的数字"></a>面试题03：数组中重复的数字</h1><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 </p></blockquote><p><strong>限制：</strong></p><blockquote><p>2 <= n <= 100000</p></blockquote><p><strong>解题思路（作者：smallpineapp1e）</strong></p><p>巧妙利用数组下标来匹配对应的元素，从前往后遍历数组，每个元素都要求下标与元素的值一一对应，如果在调换位置的过程中发现该位置的元素与别的位置的元素是相同的，那么就说明该数字重复，直接返回该数字</p><p><a href="https://pic.leetcode-cn.com/811320fa207519efeac59b157842938b61e4ec059ab9bc0ffa392babbd42da97-ezgif.com-resize.gif" data-fancybox="group" data-caption="数组与下标的完美结合" class="fancybox"><img alt="数组与下标的完美结合" title="数组与下标的完美结合" data-src="https://pic.leetcode-cn.com/811320fa207519efeac59b157842938b61e4ec059ab9bc0ffa392babbd42da97-ezgif.com-resize.gif" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] arrs)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < arr.length; i++){</span><br><span class="line">            <span class="comment">//将数字与下标对应起来</span></span><br><span class="line">            <span class="keyword">while</span> (arr[i] != i){</span><br><span class="line">                <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">                <span class="comment">//如果准备移动的数字已经等于对应位置上的数字则说明数字重复</span></span><br><span class="line">                <span class="keyword">if</span>(temp == arr[temp]) <span class="keyword">return</span> temp;</span><br><span class="line">                arr[i] = arr[temp];</span><br><span class="line">                arr[temp] = temp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>时间复杂度：O(n)，空间复杂度：O(1)</strong></p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;面试题03：数组中重复的数字&quot;&gt;&lt;a href=&quot;#面试题03：数组中重复的数字&quot; class=&quot;headerlink&quot; title=&quot;面试题03：数组中重复的数字&quot;&gt;&lt;/a&gt;面试题03：数组中重复的数字&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://qihuang7.top/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://qihuang7.top/tags/leetcode/"/>
    
      <category term="数组" scheme="https://qihuang7.top/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Spring基础（二）：AOP面向切面编程</title>
    <link href="https://qihuang7.top/2020/04/04/%E6%A1%86%E6%9E%B6/Spring%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AAOP%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/"/>
    <id>https://qihuang7.top/2020/04/04/%E6%A1%86%E6%9E%B6/Spring%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AAOP%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/</id>
    <published>2020-04-04T14:26:39.000Z</published>
    <updated>2020-04-04T16:50:20.928Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="AOP概述"><a href="#AOP概述" class="headerlink" title="AOP概述"></a>AOP概述</h1><h2 id="什么是-AOP"><a href="#什么是-AOP" class="headerlink" title="什么是 AOP"></a>什么是 AOP</h2><p>AOP 即 Aspect Oriented Program，面向切面编程</p><p>AOP将应用系统拆分为两个部分：核心业务逻辑及横向的通用逻辑，也就是所谓的切面</p><p>AOP 主要应用场景有：</p><ol><li>Authentication 权限</li><li>Caching 缓存</li><li>Context passing 内容传递</li><li>Error handling 错误处理</li><li>Lazy loading 懒加载</li><li>Debugging 调试</li><li>logging, tracing, profiling and monitoring 记录跟踪 优化 校准</li><li>Performance optimization 性能优化</li><li>Persistence 持久化</li><li>Resource pooling 资源池</li><li>Synchronization 同步</li><li>Transactions 事务</li></ol><h3 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h3><ul><li>target：目标类</li><li>joinPoint：连接点是指所有可能织入通知的方法理论上大部分方法都是连接点</li><li>pointCut：切入点，已经被增强的方法</li><li>Weaving：织入，将通知应用到目标对象来创建新的代理对象的过程。</li><li>Aspect：切面，通知所在的类就叫切面。</li><li>Weaving：织入，将通知应用到目标对象来创建新的代理对象的过程</li></ul><h2 id="AOP的实现方式：手动-了解"><a href="#AOP的实现方式：手动-了解" class="headerlink" title="AOP的实现方式：手动 (了解)"></a>AOP的实现方式：手动 (了解)</h2><p>Spring 提供了两种方式来生成代理对象: JDKProxy 和 Cglib，具体使用哪种方式生成由AopProxyFactory 根据 AdvisedSupport 对象的配置来决定。<br>默认的策略是如果目标类是接口，则使用 JDK 动态代理技术，否则使用 Cglib 来生成代理。</p><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>{</span><br><span class="line">System.out.println(<span class="string">"before...."</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>{</span><br><span class="line">System.out.println(<span class="string">"after...."</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactory</span> </span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserService <span class="title">createService</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">final</span> UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line"><span class="keyword">final</span> MyAspect myAspect = <span class="keyword">new</span> MyAspect();</span><br><span class="line">UserService proxService = (UserService)Proxy.newProxyInstance(</span><br><span class="line">                    MyBeanFactory<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),   //类加载器</span></span><br><span class="line"><span class="class"><span class="title">userService</span>.<span class="title">getClass</span>().<span class="title">getInterfaces</span>(),</span></span><br><span class="line"><span class="class"><span class="title">new</span> <span class="title">InvocationHandler</span>() </span>{ </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">myAspect.before();</span><br><span class="line">Object obj = method.invoke(userService, args);  <span class="comment">//执行目标类的方法</span></span><br><span class="line">myAspect.after();</span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">}</span><br><span class="line">});</span><br><span class="line"><span class="keyword">return</span> proxService;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo01</span><span class="params">()</span></span>{</span><br><span class="line">UserService userService = MyBeanFactory.createService();</span><br><span class="line">userService.addUser();</span><br><span class="line">userService.updateUser();</span><br><span class="line">userService.deleteUser();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="CGLIB字节码增强"><a href="#CGLIB字节码增强" class="headerlink" title="CGLIB字节码增强"></a>CGLIB字节码增强</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactory</span> </span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserServiceImpl <span class="title">createService</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">final</span> UserServiceImpl userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line"><span class="keyword">final</span> MyAspect myAspect = <span class="keyword">new</span> MyAspect();</span><br><span class="line"><span class="comment">//代理类 ，采用cglib，底层创建目标类的子类</span></span><br><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();     <span class="comment">//核心类</span></span><br><span class="line">enhancer.setSuperclass(userService.getClass());     <span class="comment">//确定父类</span></span><br><span class="line">enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor(){       <span class="comment">//设置回调函数</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">myAspect.before();</span><br><span class="line">Object obj = method.invoke(userService, args);  <span class="comment">//执行目标方法</span></span><br><span class="line">methodProxy.invokeSuper(proxy, args);   </span><br><span class="line">myAspect.after();</span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">}</span><br><span class="line">});</span><br><span class="line">UserServiceImpl proxService = (UserServiceImpl) enhancer.create();</span><br><span class="line"><span class="keyword">return</span> proxService;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h2><ul><li>前置通知 MethodBeforeAdvice 在目标方法执行前实施增强</li><li>后置通知 AfterReturningAdvice 在目标方法执行后实施增强</li><li>环绕通知 MethodInterceptor 在目标方法执行前后实施增强</li><li>异常抛出通知 ThrowsAdvice 在方法抛出异常后实施增强</li><li>引介通知 IntroductionInterceptor 在目标类中添加一些新的方法和属性</li></ul><p>其中环绕通知必须手动执行目标方法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>{</span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    <span class="comment">//执行目标方法</span></span><br><span class="line">    <span class="comment">//后置通知</span></span><br><span class="line">}<span class="keyword">catch</span>(){</span><br><span class="line">    <span class="comment">//抛出异常通知</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="Spring代理：半自动（了解）"><a href="#Spring代理：半自动（了解）" class="headerlink" title="Spring代理：半自动（了解）"></a>Spring代理：半自动（了解）</h2><p>让spring 创建代理对象，从spring容器中手动的获取代理对象。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 切面类中确定通知，需要实现不同接口，接口就是规范，从而就确定方法名称。</span></span><br><span class="line"><span class="comment"> *      MethodInterceptor:环绕通知</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>{</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">System.out.println(<span class="string">"before...."</span>);</span><br><span class="line"><span class="comment">//执行目标方法</span></span><br><span class="line">Object obj = mi.proceed();</span><br><span class="line">System.out.println(<span class="string">"after...."</span>);</span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment"><!-- Spring的配置文件applicationContext.xml --></span></span><br><span class="line"><span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userServiceId"</span> <span class="attr">class</span>=<span class="string">"com.xxx.service.impl.UserServiceImpl"</span>></span><span class="tag"><!--<span class="name"-->bean</span>></span><br><span class="line"><span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myAspectId"</span> <span class="attr">class</span>=<span class="string">"com.xxx.aspect.MyAspect"</span>></span><span class="tag"><!--<span class="name"-->bean</span>></span><br><span class="line">   <span class="comment"><!-- ProxyFactoryBean：用于创建代理工程bean生成特殊代理对象</span></span><br><span class="line"><span class="comment">           需要注入接口，以及目标类，切面类</span></span><br><span class="line"><span class="comment">   --></span></span><br><span class="line"><span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"proxyServiceId"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.ProxyFactoryBean"</span>></span></span><br><span class="line"><span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interfaces"</span> <span class="attr">value</span>=<span class="string">"com.xxx.service.UserService"</span>></span><span class="tag"><!--<span class="name"-->property</span>></span><br><span class="line"><span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span> <span class="attr">ref</span>=<span class="string">"userServiceId"</span>></span><span class="tag"><!--<span class="name"-->property</span>></span><br><span class="line"><span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span> <span class="attr">value</span>=<span class="string">"myAspectId"</span>></span><span class="tag"><!--<span class="name"-->property</span>></span><br><span class="line"><span class="tag"><!--<span class="name"-->bean</span>></span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo01</span><span class="params">()</span></span>{</span><br><span class="line">String xmlPath = <span class="string">"xxx/applicationContext.xml"</span>;</span><br><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(xmlPath);</span><br><span class="line"><span class="comment">//获得代理类</span></span><br><span class="line">UserService userService = (UserService) applicationContext.getBean(<span class="string">"proxyServiceId"</span>);</span><br><span class="line">userService.addUser();</span><br><span class="line">userService.updateUser();</span><br><span class="line">userService.deleteUser();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="Spring-AOP编程：全自动（掌握）"><a href="#Spring-AOP编程：全自动（掌握）" class="headerlink" title="Spring AOP编程：全自动（掌握）"></a>Spring AOP编程：全自动（掌握）</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userServiceId"</span> <span class="attr">class</span>=<span class="string">"com.xxx.service.impl.UserServiceImpl"</span>></span><span class="tag"><!--<span class="name"-->bean</span>></span><br><span class="line"><span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myAspectId"</span> <span class="attr">class</span>=<span class="string">"com.xxx.aspect.MyAspect"</span>></span><span class="tag"><!--<span class="name"-->bean</span>></span><br><span class="line"><span class="tag"><<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>></span></span><br><span class="line"><span class="tag"><<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* com.xxx.*.*(..))"</span> <span class="attr">id</span>=<span class="string">"myPointCut"</span>/></span></span><br><span class="line"><span class="comment"><!-- 特殊的切面：只有一个通知和一个切入点 --></span></span><br><span class="line"><span class="tag"><<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"myAspectId"</span> <span class="attr">pointcut-ref</span>=<span class="string">"myPointCut"</span>/></span></span><br><span class="line"><span class="tag"><!--<span class="name"-->aop:config</span>></span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo01</span><span class="params">()</span></span>{</span><br><span class="line">String xmlPath = <span class="string">"xxx/applicationContext.xml"</span>;</span><br><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(xmlPath);</span><br><span class="line"></span><br><span class="line">UserService userService = (UserService) applicationContext.getBean(<span class="string">"userServiceId"</span>);</span><br><span class="line">userService.addUser();</span><br><span class="line">userService.updateUser();</span><br><span class="line">userService.deleteUser();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="基于AspectJ"><a href="#基于AspectJ" class="headerlink" title="基于AspectJ"></a>基于AspectJ</h2><p>AspectJ是一个AOP框架</p><h3 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式 *"></a>切入点表达式 *</h3><p>execution(* com . xxx . * . * ( .. ))<br>excecution(修饰符（省略） 返回值 包.类.方法名(参数) throws 异常)<br>*代表任意值</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>{</span><br><span class="line">    <span class="comment">//环绕通知</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">myAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable</span>{</span><br><span class="line">System.out.println(<span class="string">"before..."</span>);</span><br><span class="line"><span class="comment">//执行目标方法</span></span><br><span class="line">Object obj = joinPoint.proceed();</span><br><span class="line">System.out.println(<span class="string">"after..."</span>);</span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userServiceId"</span> <span class="attr">class</span>=<span class="string">"com.itheima.d_aspect.a_xml.UserServiceImpl"</span>></span><span class="tag"><!--<span class="name"-->bean</span>></span><br><span class="line"><span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myAspectId"</span> <span class="attr">class</span>=<span class="string">"com.itheima.d_aspect.a_xml.MyAspect"</span>></span><span class="tag"><!--<span class="name"-->bean</span>></span><br><span class="line"><span class="tag"><<span class="name">aop:config</span>></span></span><br><span class="line"><span class="tag"><<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"myAspectId"</span>></span></span><br><span class="line"><span class="tag"><<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* com.xxx.service.impl.UserServiceImpl.*(..))"</span> <span class="attr">id</span>=<span class="string">"myPointCut"</span>/></span></span><br><span class="line"><span class="comment"><!-- 其他通知类似 --></span></span><br><span class="line"><span class="tag"><<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">"myAround"</span> <span class="attr">pointcut-ref</span>=<span class="string">"myPointCut"</span>/></span></span><br><span class="line"><span class="tag"><!--<span class="name"-->aop:config</span>></span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;AOP概述&quot;&gt;&lt;a href=&quot;#AOP概述&quot; class=&quot;headerlink&quot; title=&quot;AOP概述&quot;&gt;&lt;/a&gt;AOP概述&lt;/h1&gt;&lt;h2 id=&quot;什么是-AOP&quot;&gt;&lt;a href=&quot;#什么是-AOP&quot; 
      
    
    </summary>
    
    
      <category term="框架" scheme="https://qihuang7.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="spring" scheme="https://qihuang7.top/categories/%E6%A1%86%E6%9E%B6/spring/"/>
    
    
      <category term="基础" scheme="https://qihuang7.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="SSM" scheme="https://qihuang7.top/tags/SSM/"/>
    
      <category term="spring" scheme="https://qihuang7.top/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：圆圈中最后剩下的数字</title>
    <link href="https://qihuang7.top/2020/04/04/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://qihuang7.top/2020/04/04/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2020-04-04T12:37:29.000Z</published>
    <updated>2020-04-04T12:40:28.776Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="62-圆圈中最后剩下的数字"><a href="#62-圆圈中最后剩下的数字" class="headerlink" title="62.圆圈中最后剩下的数字"></a>62.圆圈中最后剩下的数字</h1><p><strong>难度：</strong> 简单</p><p><strong>题目：</strong> 0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p><p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p><hr><p><strong>示例1：输入：</strong> n = 5，m = 3    <strong>输出：</strong> 3</p><p><strong>示例2：输入：</strong> n = 10，m = 17    <strong>输出：</strong> 2</p><hr><p><strong>限制：</strong> </p><ul><li>1 <= n <=10^5     </li><li>1 <= m <=10^6</li></ul><p><strong>解题1 模拟做法</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>{</span><br><span class="line">        ArrayList<integer> list = <span class="keyword">new</span> ArrayList<>(n);</integer></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < n; i++) {</span><br><span class="line">            list.add(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n > <span class="number">1</span>) {</span><br><span class="line">            idx = (idx + m - <span class="number">1</span>) % n;</span><br><span class="line">            list.remove(idx);</span><br><span class="line">            n--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>思路</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n=5,m=3,idx=00 1 2 3 4</span><br><span class="line">n=5idx=(0+3-1)%5=2%5=2remove(2)0 1 3 4</span><br><span class="line">n=4idx=(2+3-1)%4=4%4=0remove(0)1 3 4</span><br><span class="line">n=3idx=(0+3-1)%3=2%3=2remove(2)1 3</span><br><span class="line">n=2idx=(2+3-1)%2=4%2=0remove(0)3</span><br><span class="line">n=1</span><br></pre></td></tr></tbody></table></figure></div><p><strong>题解2 数学方法</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 最后一轮剩下2个人，所以从2开始反推</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i <= n; i++) {</span><br><span class="line">            ans = (ans + m) % i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;62-圆圈中最后剩下的数字&quot;&gt;&lt;a href=&quot;#62-圆圈中最后剩下的数字&quot; class=&quot;headerlink&quot; title=&quot;62.圆圈中最后剩下的数字&quot;&gt;&lt;/a&gt;62.圆圈中最后剩下的数字&lt;/h1&gt;&lt;p&gt;&lt;
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://qihuang7.top/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://qihuang7.top/tags/leetcode/"/>
    
  </entry>
  
</feed>
