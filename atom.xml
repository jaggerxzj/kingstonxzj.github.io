<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>七皇</title>
  <icon>https://www.gravatar.com/avatar/f1ffc9e0a95c344bc9636e7512958903</icon>
  <subtitle>KingstonXZJ</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://qihuang7.top/"/>
  <updated>2020-04-06T16:05:11.095Z</updated>
  <id>https://qihuang7.top/</id>
  
  <author>
    <name>七皇</name>
    <email>kingstonxzj@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java多线程基础（七）：volatile关键字</title>
    <link href="https://qihuang7.top/2020/04/07/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9Avolatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://qihuang7.top/2020/04/07/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9Avolatile%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2020-04-06T16:00:26.000Z</published>
    <updated>2020-04-06T16:05:11.095Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="第七章-volatile关键字"><a href="#第七章-volatile关键字" class="headerlink" title="第七章 volatile关键字"></a>第七章 volatile关键字</h1><h2 id="volatile的内存语义"><a href="#volatile的内存语义" class="headerlink" title="volatile的内存语义"></a>volatile的内存语义</h2><p>volatile关键字主要有以下两个功能：</p><ul><li>保证变量的 <strong>内存可见性</strong></li><li>禁止 volatile 变量与普通变量 <strong>重排序</strong></li></ul><h3 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h3><p>示例代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>{</span><br><span class="line">        a = <span class="number">1</span>; <span class="comment">// step 1</span></span><br><span class="line">        flag = <span class="keyword">true</span>; <span class="comment">// step 2</span></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (flag) { <span class="comment">// step 3</span></span><br><span class="line">            System.out.println(a); <span class="comment">// step 4</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>在这段代码里，我们使用 volatile 关键字修饰了一个 boolean 类型的变量 flag</p><blockquote><p><strong>所谓内存可见性，指的时当一个线程对 volatile 修饰的变量进行写操作（比如step2）时，JMM 会立即把该线程对应的本地内存中的共享变量的值刷新到主内存；当一个线程对 volatile 修饰的变量进行读操作（比如step3）时，JMM会立即把该线程对应的本地内存置为无效，从主内存中读取共享变量的值。</strong></p></blockquote><p>假设在时间线上，线程A先执行 writer 方法，线程B后执行 reader 方法。那么必然会有下图：<br><a href="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/volatile.PNG" data-fancybox="group" data-caption="程序执行步骤与主内存变化" class="fancybox"><img alt="程序执行步骤与主内存变化" title="程序执行步骤与主内存变化" data-src="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/volatile.PNG" class="lazyload"></a></p><p>如果 flag变量 没有用 volatile 修饰，在step2的变量就不会立即更新到主内存，线程B 也不会拿到最新的值，仍然使用B本地内存缓存的变量值 a = 0,flag = false.</p><h3 id="禁止重排序"><a href="#禁止重排序" class="headerlink" title="禁止重排序"></a>禁止重排序</h3><p><strong>在旧的java内存模型中，是允许 volatile变量 与普通变量重排序的。</strong> 上面的案例就可能会被重排序成下列时序来执行：  </p><ol><li>线程A写volatile变量，step2，设置flag 为true；  </li><li>线程B读同一个volatile，step3，读取到flag 为true； </li><li>线程B读普通变量，step4，读取到a = 0；  </li><li>线程A修改普通变量，step1，设置a = 1;</li></ol><p>可见，如果 volatile变量与普通变量发生了重排序，虽然 volatile变量能保证内存可见性，也可能导致普通变量读取错误。</p><p>为了提供一种比锁更轻量级的线程间的通信机制，JSR-133专家组决定增强 volatile的内存语义：<strong>严格限制编译器和处理器对volatile变量与普通变量的重排序。</strong></p><h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><h4 id="JVM是怎么限制处理器的重排序的呢？"><a href="#JVM是怎么限制处理器的重排序的呢？" class="headerlink" title="JVM是怎么限制处理器的重排序的呢？"></a>JVM是怎么限制处理器的重排序的呢？</h4><p>它是通过 <strong>内存屏障</strong> 来实现的</p><blockquote><p>硬件层面，内存屏障分两种：<strong>读屏障（Load Barrier）和写屏障（Store Barrier）</strong>。</p></blockquote><p><strong>内存屏障有两个作用：</strong>  </p><p><strong>1.阻止屏障两侧的指令重排序；</strong><br><strong>2.强制把写缓冲区/高速缓存中的脏数据等写回主内存，或者让缓存中相应的数据失效。</strong></p><p>编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。编译器选择了一个比较保守的<strong>JMM内存屏障插入策略：</strong></p><ul><li>在每个 volatile写操作 前 插入一个 StoreStore屏障；</li><li>在每个 volatile写操作 后 插入一个 StoreLoad屏障；</li><li>在每个 volatile读操作 后 插入一个 LoadLoad屏障；</li><li>在每个 volatile读操作 后 插入一个 LoadStore屏障。</li></ul><p>示意图：<br><a href="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/JMM%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E6%8F%92%E2%BC%8A%E7%AD%96%E7%95%A5.PNG" data-fancybox="group" data-caption="JMM内存屏障插入策略" class="fancybox"><img alt="JMM内存屏障插入策略" title="JMM内存屏障插入策略" data-src="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/JMM%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E6%8F%92%E2%BC%8A%E7%AD%96%E7%95%A5.PNG" class="lazyload"></a></p><p><strong>volatile与普通变量的重排序规则：</strong><br><strong>1. 如果第⼀个操作是volatile读，那⽆论第⼆个操作是什么，都不能重排序；</strong><br><strong>2. 如果第⼆个操作是volatile写，那⽆论第⼀个操作是什么，都不能重排序；</strong><br><strong>3. 如果第⼀个操作是volatile写，第⼆个操作是volatile读，那不能重排序。</strong>  </p><blockquote><p>在案例中step 1，是普通变量的写，step2是volatile变量的写，那符合第2个规则，这两个steps不能重排序。⽽step3是volatile变量读，step4是普通变量读，符合第1个规则，同样不能重排序。</p></blockquote><p>如果是第一个操作是普通变量读，第二个操作是volatile变量读，那是可以重排序的：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明变量</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>; <span class="comment">// 声明普通变量</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">// 声明volatile变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下两个变量的读操作是可以重排序的</span></span><br><span class="line"><span class="keyword">int</span> i = a; <span class="comment">// 普通变量读</span></span><br><span class="line"><span class="keyword">boolean</span> j = flag; <span class="comment">// volatile变量读</span></span><br></pre></td></tr></tbody></table></figure></div><h2 id="volatile的用途"><a href="#volatile的用途" class="headerlink" title="volatile的用途"></a>volatile的用途</h2><p>在保存内存可见性这一点上，volatile有着与锁相同的内存语义，所以 <strong>可以作为一个“轻量级”的锁来使用</strong> 。但由于volatile仅仅保证对单个volatile变量的读/写具有原子性，而锁可以保证整个临界区代码的执行具有原子性。所以 <strong>在功能上，锁比volatile更强大； 在性能上，volatile更有优势</strong></p><h3 id="单例模式中volatile的应用"><a href="#单例模式中volatile的应用" class="headerlink" title="单例模式中volatile的应用"></a>单例模式中volatile的应用</h3><p><strong>“双重锁检查”</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance; </span><br><span class="line">    <span class="comment">// 双重锁检验</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) { <span class="comment">// 第7⾏</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>{</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton(); </span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;第七章-volatile关键字&quot;&gt;&lt;a href=&quot;#第七章-volatile关键字&quot; class=&quot;headerlink&quot; title=&quot;第七章 volatile关键字&quot;&gt;&lt;/a&gt;第七章 volatile关键字&lt;
      
    
    </summary>
    
    
      <category term="java基础" scheme="https://qihuang7.top/categories/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="https://qihuang7.top/categories/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://qihuang7.top/tags/java/"/>
    
      <category term="基础" scheme="https://qihuang7.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="https://qihuang7.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="volatile" scheme="https://qihuang7.top/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>java多线程基础（六）：重排序与happens-before</title>
    <link href="https://qihuang7.top/2020/04/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E9%87%8D%E6%8E%92%E5%BA%8F%E4%B8%8Ehappens-before/"/>
    <id>https://qihuang7.top/2020/04/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E9%87%8D%E6%8E%92%E5%BA%8F%E4%B8%8Ehappens-before/</id>
    <published>2020-04-06T15:45:26.000Z</published>
    <updated>2020-04-06T16:01:17.512Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="第六章-重排序与happens-before"><a href="#第六章-重排序与happens-before" class="headerlink" title="第六章 重排序与happens-before"></a>第六章 重排序与happens-before</h1><h2 id="什么是重排序？"><a href="#什么是重排序？" class="headerlink" title="什么是重排序？"></a>什么是重排序？</h2><p><strong>为优化程序性能，对原有的指令执行顺序进行优化重新排序。</strong> </p><blockquote><p>每一个指令都会包含多个步骤，每个步骤可能使用不同的硬件。因此 <strong>流水线技术</strong> 产生了，它的原理是 <strong>指令1还没有执行完，就可以开始执行指令2，而不用等到指令1执行结束之后再执行指令2，这样就大大提高了效率</strong></p></blockquote><p>流水线技术最害怕 <strong>中断</strong>，恢复中断的代价是比较大的，<strong>指令重排就是减少中断的一种技术。</strong></p><p>指令重排一般分为以下三种：</p><ul><li><strong>编译器优化重排</strong> </li><li><strong>指令并行重排</strong></li><li><strong>内存系统重排</strong></li></ul><h2 id="顺序一致性模型"><a href="#顺序一致性模型" class="headerlink" title="顺序一致性模型"></a>顺序一致性模型</h2><p>顺序一致性模型是一个 <strong>理论参考模型</strong> ，它为程序员提供了 <strong>极强的内存可见性保证。</strong></p><h3 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h3><p><strong>内存可见性，指的是线程之间的可见性，当一个线程修改了共享变量时，另一个线程可以读取到这个修改后的值。</strong></p><h3 id="数据竞争与顺序一致性"><a href="#数据竞争与顺序一致性" class="headerlink" title="数据竞争与顺序一致性"></a>数据竞争与顺序一致性</h3><p>当程序未正确同步的时候，就可能存在数据竞争，运行的结果往往充满了不确定性。</p><blockquote><p>数据竞争：在一个线程中写一个变量，另一个线程读同一个变量，并且写和读没有通过同步来排序。</p></blockquote><h3 id="顺序一致性模型有两大特性："><a href="#顺序一致性模型有两大特性：" class="headerlink" title="顺序一致性模型有两大特性："></a>顺序一致性模型有两大特性：</h3><ul><li>一个线程中的所有操作必须按照程序的顺序来执行</li><li>每个操作必须是原子性的，且立刻对所有线程可见</li></ul><p>假设有两个线程 A 和 B 并发执行，线程 A 有3个操作，它们在程序中的顺序是 A1->A2->A3 ，线程 B 也有3个操作，B1->B2->B3</p><p>假设 <strong>正确使用了同步</strong> ，A 线程的3个操作执行后释放锁，B线程获取同一个锁。那么在顺序一致性模型中的执行效果如下所示：</p><p><strong>A1–>A2–>A3–>B1–>B2–>B3</strong></p><p>假设 <strong>没有使用同步</strong> ，那么在顺序一致性模型中的执行效果如下所示：</p><p><strong>B1–>A1–>A2–>B2–>A3–>B3</strong></p><h2 id="happens-before规则"><a href="#happens-before规则" class="headerlink" title="happens-before规则"></a>happens-before规则</h2><p>只要程序员在写代码时遵循 happens-before 规则，JVM就能保证指令在多线程之间的顺序性符合程序员的预期</p><p><strong>天然的happens-before关系：</strong></p><ul><li><strong>程序顺序规则</strong>：⼀个线程中的每⼀个操作，happens-before于该线程中的任意后续操作</li><li><strong>监视器锁规则</strong>：对⼀个锁的解锁，happens-before于随后对这个锁的加锁</li><li><strong>volatile变量规则</strong>：对⼀个volatile域的写，happens-before于任意后续对这个 volatile 域的读。</li><li><strong>传递性</strong>：如果A happens-before B，且B happens-before C，那么A happensbefore C。</li><li><strong>start规则</strong>：如果线程A执⾏操作ThreadB.start()启动线程B，那么A线程的 ThreadB.start（）操作happens-before于线程B中的任意操作</li><li><strong>join规则</strong>：如果线程A执⾏操作ThreadB.join（）并成功返回，那么线程B中的任意操作 happens-before 于线程A从ThreadB.join()操作成功返回。</li></ul></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;第六章-重排序与happens-before&quot;&gt;&lt;a href=&quot;#第六章-重排序与happens-before&quot; class=&quot;headerlink&quot; title=&quot;第六章 重排序与happens-before&quot;
      
    
    </summary>
    
    
      <category term="java基础" scheme="https://qihuang7.top/categories/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="https://qihuang7.top/categories/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://qihuang7.top/tags/java/"/>
    
      <category term="基础" scheme="https://qihuang7.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="https://qihuang7.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：合并排序的数组</title>
    <link href="https://qihuang7.top/2020/04/06/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84/"/>
    <id>https://qihuang7.top/2020/04/06/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84/</id>
    <published>2020-04-05T16:43:29.000Z</published>
    <updated>2020-04-05T16:44:06.528Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="面试题10-01-合并排序的数组"><a href="#面试题10-01-合并排序的数组" class="headerlink" title="面试题10.01 合并排序的数组"></a>面试题10.01 合并排序的数组</h1><p>给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。</p><p>初始化 A 和 B 的元素数量分别为 m 和 n。</p><p><strong>示例:</strong></p><blockquote><p>输入:<br>A = [1,2,3,0,0,0], m = 3<br>B = [2,5,6],       n = 3<br>输出: [1,2,2,3,5,6]</p></blockquote><p>说明:</p><blockquote><p>A.length == n + m</p></blockquote><p><strong>暴力解法：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> m, <span class="keyword">int</span>[] B, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m;i<m+n;i++){< span><br><span class="line">            A[i] = B[j++];</span><br><span class="line">        }</span><br><span class="line">        Arrays.sort(A);</span><br><span class="line">    }</span><br><span class="line">}</span><br></m+n;i++){<></span></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;面试题10-01-合并排序的数组&quot;&gt;&lt;a href=&quot;#面试题10-01-合并排序的数组&quot; class=&quot;headerlink&quot; title=&quot;面试题10.01 合并排序的数组&quot;&gt;&lt;/a&gt;面试题10.01 合并排序
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://qihuang7.top/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://qihuang7.top/tags/leetcode/"/>
    
      <category term="数组" scheme="https://qihuang7.top/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="排序" scheme="https://qihuang7.top/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>java多线程基础（五）：线程间的通信</title>
    <link href="https://qihuang7.top/2020/04/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/"/>
    <id>https://qihuang7.top/2020/04/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/</id>
    <published>2020-04-05T12:54:26.000Z</published>
    <updated>2020-04-05T12:54:38.791Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="第五章-Java线程间的通信"><a href="#第五章-Java线程间的通信" class="headerlink" title="第五章 Java线程间的通信"></a>第五章 Java线程间的通信</h1><h2 id="锁与同步"><a href="#锁与同步" class="headerlink" title="锁与同步"></a>锁与同步</h2><p>锁的概念都是 <strong>基于对象</strong> 的，所以又称它为“对象锁”。</p><p><strong>一个锁同一时间只能被一个线程持有。</strong> </p><p><strong>线程同步是线程之间按照一定的顺序执行</strong></p><blockquote><p>假如我们现在有2位正在抄暑假作业答案的同学：线程A和线程B。当他们正在抄的时候，⽼师突然来修改了⼀些答案，可能A和B最后写出的暑假作业就不⼀样。我们为了A,B能写出2本相同的暑假作业，我们就需要让⽼师先修改答案，然后A，B同学再抄。或者A，B同学先抄完，⽼师再修改答案。这就是线程A，线程B的线程同步。</p></blockquote><p>首先看一个无锁的程序：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoneLock</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">100</span>; i++) {</span><br><span class="line">                System.out.println(<span class="string">"Thread A "</span> + i);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">100</span>; i++) {</span><br><span class="line">                System.out.println(<span class="string">"Thread B "</span> + i);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadA()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadB()).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*执行结果：线程 A 和线程 B 各⾃独⽴⼯作，输出⾃⼰的打印值。</span></span><br><span class="line"><span class="comment">    ....</span></span><br><span class="line"><span class="comment">    Thread A 48</span></span><br><span class="line"><span class="comment">    Thread A 49</span></span><br><span class="line"><span class="comment">    Thread B 0</span></span><br><span class="line"><span class="comment">    Thread A 50</span></span><br><span class="line"><span class="comment">    Thread B 1</span></span><br><span class="line"><span class="comment">    Thread A 51</span></span><br><span class="line"><span class="comment">    Thread A 52</span></span><br><span class="line"><span class="comment">    ....</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure></div><p>如果需要 <strong>A先执行完之后再由B去执行</strong> 该怎么做？<br>最简单的⽅式就是使⽤⼀个“对象锁”：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectLock</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">100</span>; i++) {</span><br><span class="line">                    System.out.println(<span class="string">"Thread A "</span> + i);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">100</span>; i++) {</span><br><span class="line">                    System.out.println(<span class="string">"Thread B "</span> + i);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadA()).start();</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadB()).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>线程B 就会等线程A 执行完成后释放 lock ,线程B 才能获得锁 lock 。</p><blockquote><p>这⾥在主线程⾥使⽤ sleep⽅法 睡眠了10毫秒，是为了防⽌线程B先得到锁。 因为如果同时 start，线程 A 和线程 B 都是出于就绪状态，操作系统可能会先让 B 运行。这样就会先输出 B 的内容，然后 B 执行完成之后⾃动释放锁，线程 A 再执行。</p></blockquote><h2 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h2><p>多线程的等待/通知机制是基于 Object 类的 wait() 方法和 notify() ,notifyAll() 方法来实现的</p><blockquote><p>notify()方法会随机叫醒一个正在等待的线程  ，notifyAll() 会叫醒所有正在等待的线程。</p></blockquote><p>假如 线程A 现在持有一个 锁lock 并开始执行，它可以使用 lock.wait() 让自己进入等待状态，lock锁 被释放。这时，线程B 获得了 lock锁 并开始执行，在某个时刻使用 lock.notify()，通知等待状态的 A，但是 线程B 并没有释放锁，除非 B 使用 lock.wait() 或者B 执行结束自行释放锁，A 才能得到 lock锁</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitAndNotify</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">5</span>; i++) {</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        System.out.println(<span class="string">"ThreadA: "</span> + i);</span><br><span class="line">                        lock.notify();</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                lock.notify();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">5</span>; i++) {</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        System.out.println(<span class="string">"ThreadB: "</span> + i);</span><br><span class="line">                        lock.notify();</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                lock.notify();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadA()).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadB()).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">    ThreadA: 0</span></span><br><span class="line"><span class="comment">    ThreadB: 0</span></span><br><span class="line"><span class="comment">    ThreadA: 1</span></span><br><span class="line"><span class="comment">    ThreadB: 1</span></span><br><span class="line"><span class="comment">    ThreadA: 2</span></span><br><span class="line"><span class="comment">    ThreadB: 2</span></span><br><span class="line"><span class="comment">    ThreadA: 3</span></span><br><span class="line"><span class="comment">    ThreadB: 3</span></span><br><span class="line"><span class="comment">    ThreadA: 4</span></span><br><span class="line"><span class="comment">    ThreadB: 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure></div><p>线程A 和线程B 首先打印出自己需要的东西，然后使用 notify() 方法叫醒另一个正在等待的线程，然后自己使用 wait() 方法陷入等待并释放lock锁。</p><blockquote><p><strong>等待/通知机制使用的是使用同⼀个对象</strong></p></blockquote><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>基于 volatile 关键字的⾃⼰实现的信号量通信。</p><blockquote><p>volitile关键字能够 <strong>保证内存的可⻅性</strong>，如果⽤volitile关键字声明了⼀个变量，在⼀个线程⾥⾯改变了这个变量的值，那其它线程是 <strong>⽴⻢可⻅更改后的值</strong> 的。</p></blockquote><p>需求：让 线程A 输出0，然后 线程B 输出1，再然后 线程A 输出2…以此类推。</p><p>代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Signal</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> signal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">while</span> (signal < <span class="number">5</span>) {</span><br><span class="line">                <span class="keyword">if</span> (signal % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">                    System.out.println(<span class="string">"threadA: "</span> + signal);</span><br><span class="line">                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">                        signal++;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">while</span> (signal < <span class="number">5</span>) {</span><br><span class="line">                <span class="keyword">if</span> (signal % <span class="number">2</span> == <span class="number">1</span>) {</span><br><span class="line">                    System.out.println(<span class="string">"threadB: "</span> + signal);</span><br><span class="line">                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">                        signal = signal + <span class="number">1</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadA()).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadB()).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">    threadA: 0</span></span><br><span class="line"><span class="comment">    threadB: 1</span></span><br><span class="line"><span class="comment">    threadA: 2</span></span><br><span class="line"><span class="comment">    threadB: 3</span></span><br><span class="line"><span class="comment">    threadA: 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure></div><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道是基于“管道流”的通信方式。JDK提供了 Pipedwriter、 PipedReader、 PipedOutputStream、 PipedInputStream。其中，前面两个是基于字符的，后面两个是基于字节流的。</p><p>示例代码：基于字符的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pipe</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> PipedReader reader;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ReaderThread</span><span class="params">(PipedReader reader)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.reader = reader;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            System.out.println(<span class="string">"this is reader"</span>);</span><br><span class="line">            <span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">while</span> ((receive = reader.read()) != -<span class="number">1</span>) {</span><br><span class="line">                    System.out.print((<span class="keyword">char</span>) receive);</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriterThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> PipedWriter writer;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WriterThread</span><span class="params">(PipedWriter writer)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.writer = writer;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            System.out.println(<span class="string">"this is writer"</span>);</span><br><span class="line">            <span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                writer.write(<span class="string">"test"</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    writer.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>{</span><br><span class="line">        PipedWriter writer = <span class="keyword">new</span> PipedWriter();</span><br><span class="line">        PipedReader reader = <span class="keyword">new</span> PipedReader();</span><br><span class="line">        writer.connect(reader); <span class="comment">// 这⾥注意⼀定要连接，才能通信</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ReaderThread(reader)).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> WriterThread(writer)).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">        this is reader</span></span><br><span class="line"><span class="comment">        this is writer</span></span><br><span class="line"><span class="comment">        test</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure></div><p>执行流程：</p><ol><li>线程ReaderThread开始执行， </li><li>线程ReaderThread使用管道reader.read()进⼊“阻塞”， </li><li>线程WriterThread开始执行， </li><li>线程WriterThread⽤writer.write(“test”)往管道写⼊字符串， </li><li>线程WriterThread使⽤writer.close()结束管道写⼊，并执行完毕， </li><li>线程ReaderThread接受到管道输出的字符串并打印， </li><li>线程ReaderThread执行完毕。</li></ol><blockquote><p>管道通信的应用场景：多半与I/O流相关。当我们一个线程需要另一个线程发送一个信息（比如字符串）或者文件等等时，就需要使用管道通信了。</p></blockquote><h2 id="其他通信"><a href="#其他通信" class="headerlink" title="其他通信"></a>其他通信</h2><ul><li><strong>join方法：</strong> 如果主线程想等待子线程执行完毕后 <strong>获得子线程中处理完的某个数据</strong>，就要用到 join方法 了</li><li><strong>sleep方法：sleep方法时不会释放当前的锁，容易死锁，而wait方法会。sleep方法必须指定时间。wait方法必须放在同步块或同步方法中,而sleep可以在任意位置。</strong></li><li>ThreadLocal类：它为每个线程都创建⼀个副本，每个线程可以访问⾃⼰内部的副本变量。</li><li>InheritableThreadLocal：它不仅仅是当前线程可以存取副本值，⽽且它的⼦线程也可以存取这个副本值。</li></ul></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;第五章-Java线程间的通信&quot;&gt;&lt;a href=&quot;#第五章-Java线程间的通信&quot; class=&quot;headerlink&quot; title=&quot;第五章 Java线程间的通信&quot;&gt;&lt;/a&gt;第五章 Java线程间的通信&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="java基础" scheme="https://qihuang7.top/categories/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="https://qihuang7.top/categories/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://qihuang7.top/tags/java/"/>
    
      <category term="基础" scheme="https://qihuang7.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="https://qihuang7.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="通信" scheme="https://qihuang7.top/tags/%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>Spring基础（三）：IOC与AOP基于注解方式</title>
    <link href="https://qihuang7.top/2020/04/05/%E6%A1%86%E6%9E%B6/Spring%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AIOC%E4%B8%8EAOP%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F/"/>
    <id>https://qihuang7.top/2020/04/05/%E6%A1%86%E6%9E%B6/Spring%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AIOC%E4%B8%8EAOP%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F/</id>
    <published>2020-04-05T09:10:39.000Z</published>
    <updated>2020-04-05T09:11:56.263Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="IOC与AOP基于注解"><a href="#IOC与AOP基于注解" class="headerlink" title="IOC与AOP基于注解"></a>IOC与AOP基于注解</h1><p>首先修改配置文件applicationContext.xml，表示告诉Spring要使用注解的方式进行配置<br><strong>一般情况两个配置不一起使用。</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><!-- 扫描含有注解（@Component 等）类，注入注解自动生效 --></span></span><br><span class="line"><span class="tag"><<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">" "</span>></span></span><br><span class="line"><span class="comment"><!--只在xml和注解（注入）混合使用时，使注入注解生效。--></span></span><br><span class="line"><span class="tag"><<span class="name">context:annotation-config</span>></span></span><br></pre></td></tr></tbody></table></figure></div><h2 id="IOC注解"><a href="#IOC注解" class="headerlink" title="IOC注解"></a>IOC注解</h2><ol><li>@Component：组件，用于实现ioc控制反转,属性value用于实现对象id定义</li><li>@Scope：作用域，用于实现单例，多例，request，session等的配置</li><li><strong>@Controller：</strong> 专门用于controller层的注解</li><li><strong>@Service：</strong> 专门用于service层的注解</li><li><strong>@Repository：</strong> 专门用于DAO持久层的注解</li><li>@Resouce：注解会转而查找和属性类型相匹配Bean组件并注入。</li><li><strong>@Autowired：</strong> 自动注入</li></ol><h2 id="AOP注解"><a href="#AOP注解" class="headerlink" title="AOP注解"></a>AOP注解</h2><p>首先要在配置文件中开启对aop注解的支持</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><!-- 开启 spring 对注解 AOP 的支持 --></span> </span><br><span class="line"><span class="tag"><<span class="name">aop:aspectj-autoproxy</span>/></span></span><br></pre></td></tr></tbody></table></figure></div><ol><li>@Aaspet：表示当前类是一个切面类</li><li>@AfterReturning：后置通知，属性value用于指定切入点表达式</li><li>@AfterThrowing：异常通知</li><li>@After：最终通知</li><li>@Around：环绕通知<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 环绕通知 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="meta">@Around</span>(<span class="string">"execution(* com.dustdawn.service.impl.*.*(..))"</span>) </span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transactionAround</span><span class="params">(ProceedingJoinPoint pjp)</span> </span>{ </span><br><span class="line">    <span class="comment">//定义返回值 </span></span><br><span class="line">    Object rtValue = <span class="keyword">null</span>; </span><br><span class="line">    <span class="keyword">try</span> { </span><br><span class="line">        <span class="comment">//获取方法执行所需的参数 </span></span><br><span class="line">        Object[] args = pjp.getArgs(); </span><br><span class="line">        <span class="comment">//前置通知：开启事务 </span></span><br><span class="line">        beginTransaction(); </span><br><span class="line">        <span class="comment">//执行方法 </span></span><br><span class="line">        rtValue = pjp.proceed(args); </span><br><span class="line">        <span class="comment">//后置通知：提交事务 </span></span><br><span class="line">        commit(); </span><br><span class="line">    }<span class="keyword">catch</span>(Throwable e) { </span><br><span class="line">        <span class="comment">//异常通知：回滚事务 </span></span><br><span class="line">        rollback(); </span><br><span class="line">        e.printStackTrace(); </span><br><span class="line">    }<span class="keyword">finally</span> { </span><br><span class="line">        <span class="comment">//最终通知：释放资源 </span></span><br><span class="line">        release(); </span><br><span class="line">    } </span><br><span class="line">    <span class="keyword">return</span> rtValue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></li><li>@Pointcut：用于指定切入点表达式，使用方式：<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* com.xxx.service.impl.*.*(..))"</span>) </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pt1</span><span class="params">()</span> </span>{} </span><br><span class="line"></span><br><span class="line"><span class="meta">@Around</span>(<span class="string">"pt1()"</span>)   <span class="comment">//注意：千万别忘了写括号 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transactionAround</span><span class="params">(ProceedingJoinPoint pjp)</span> </span>{ </span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></li></ol></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;IOC与AOP基于注解&quot;&gt;&lt;a href=&quot;#IOC与AOP基于注解&quot; class=&quot;headerlink&quot; title=&quot;IOC与AOP基于注解&quot;&gt;&lt;/a&gt;IOC与AOP基于注解&lt;/h1&gt;&lt;p&gt;首先修改配置文件a
      
    
    </summary>
    
    
      <category term="框架" scheme="https://qihuang7.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="spring" scheme="https://qihuang7.top/categories/%E6%A1%86%E6%9E%B6/spring/"/>
    
    
      <category term="基础" scheme="https://qihuang7.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="SSM" scheme="https://qihuang7.top/tags/SSM/"/>
    
      <category term="spring" scheme="https://qihuang7.top/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：数组中重复的数字</title>
    <link href="https://qihuang7.top/2020/04/04/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://qihuang7.top/2020/04/04/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2020-04-04T15:30:29.000Z</published>
    <updated>2020-04-04T15:30:33.300Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="面试题03：数组中重复的数字"><a href="#面试题03：数组中重复的数字" class="headerlink" title="面试题03：数组中重复的数字"></a>面试题03：数组中重复的数字</h1><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 </p></blockquote><p><strong>限制：</strong></p><blockquote><p>2 <= n <= 100000</p></blockquote><p><strong>解题思路（作者：smallpineapp1e）</strong></p><p>巧妙利用数组下标来匹配对应的元素，从前往后遍历数组，每个元素都要求下标与元素的值一一对应，如果在调换位置的过程中发现该位置的元素与别的位置的元素是相同的，那么就说明该数字重复，直接返回该数字</p><p><a href="https://pic.leetcode-cn.com/811320fa207519efeac59b157842938b61e4ec059ab9bc0ffa392babbd42da97-ezgif.com-resize.gif" data-fancybox="group" data-caption="数组与下标的完美结合" class="fancybox"><img alt="数组与下标的完美结合" title="数组与下标的完美结合" data-src="https://pic.leetcode-cn.com/811320fa207519efeac59b157842938b61e4ec059ab9bc0ffa392babbd42da97-ezgif.com-resize.gif" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] arrs)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < arr.length; i++){</span><br><span class="line">            <span class="comment">//将数字与下标对应起来</span></span><br><span class="line">            <span class="keyword">while</span> (arr[i] != i){</span><br><span class="line">                <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">                <span class="comment">//如果准备移动的数字已经等于对应位置上的数字则说明数字重复</span></span><br><span class="line">                <span class="keyword">if</span>(temp == arr[temp]) <span class="keyword">return</span> temp;</span><br><span class="line">                arr[i] = arr[temp];</span><br><span class="line">                arr[temp] = temp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>时间复杂度：O(n)，空间复杂度：O(1)</strong></p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;面试题03：数组中重复的数字&quot;&gt;&lt;a href=&quot;#面试题03：数组中重复的数字&quot; class=&quot;headerlink&quot; title=&quot;面试题03：数组中重复的数字&quot;&gt;&lt;/a&gt;面试题03：数组中重复的数字&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://qihuang7.top/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://qihuang7.top/tags/leetcode/"/>
    
      <category term="数组" scheme="https://qihuang7.top/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Spring基础（二）：AOP面向切面编程</title>
    <link href="https://qihuang7.top/2020/04/04/%E6%A1%86%E6%9E%B6/Spring%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AAOP%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/"/>
    <id>https://qihuang7.top/2020/04/04/%E6%A1%86%E6%9E%B6/Spring%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AAOP%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/</id>
    <published>2020-04-04T14:26:39.000Z</published>
    <updated>2020-04-04T16:50:20.928Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="AOP概述"><a href="#AOP概述" class="headerlink" title="AOP概述"></a>AOP概述</h1><h2 id="什么是-AOP"><a href="#什么是-AOP" class="headerlink" title="什么是 AOP"></a>什么是 AOP</h2><p>AOP 即 Aspect Oriented Program，面向切面编程</p><p>AOP将应用系统拆分为两个部分：核心业务逻辑及横向的通用逻辑，也就是所谓的切面</p><p>AOP 主要应用场景有：</p><ol><li>Authentication 权限</li><li>Caching 缓存</li><li>Context passing 内容传递</li><li>Error handling 错误处理</li><li>Lazy loading 懒加载</li><li>Debugging 调试</li><li>logging, tracing, profiling and monitoring 记录跟踪 优化 校准</li><li>Performance optimization 性能优化</li><li>Persistence 持久化</li><li>Resource pooling 资源池</li><li>Synchronization 同步</li><li>Transactions 事务</li></ol><h3 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h3><ul><li>target：目标类</li><li>joinPoint：连接点是指所有可能织入通知的方法理论上大部分方法都是连接点</li><li>pointCut：切入点，已经被增强的方法</li><li>Weaving：织入，将通知应用到目标对象来创建新的代理对象的过程。</li><li>Aspect：切面，通知所在的类就叫切面。</li><li>Weaving：织入，将通知应用到目标对象来创建新的代理对象的过程</li></ul><h2 id="AOP的实现方式：手动-了解"><a href="#AOP的实现方式：手动-了解" class="headerlink" title="AOP的实现方式：手动 (了解)"></a>AOP的实现方式：手动 (了解)</h2><p>Spring 提供了两种方式来生成代理对象: JDKProxy 和 Cglib，具体使用哪种方式生成由AopProxyFactory 根据 AdvisedSupport 对象的配置来决定。<br>默认的策略是如果目标类是接口，则使用 JDK 动态代理技术，否则使用 Cglib 来生成代理。</p><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>{</span><br><span class="line">System.out.println(<span class="string">"before...."</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>{</span><br><span class="line">System.out.println(<span class="string">"after...."</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactory</span> </span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserService <span class="title">createService</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">final</span> UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line"><span class="keyword">final</span> MyAspect myAspect = <span class="keyword">new</span> MyAspect();</span><br><span class="line">UserService proxService = (UserService)Proxy.newProxyInstance(</span><br><span class="line">                    MyBeanFactory<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),   //类加载器</span></span><br><span class="line"><span class="class"><span class="title">userService</span>.<span class="title">getClass</span>().<span class="title">getInterfaces</span>(),</span></span><br><span class="line"><span class="class"><span class="title">new</span> <span class="title">InvocationHandler</span>() </span>{ </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">myAspect.before();</span><br><span class="line">Object obj = method.invoke(userService, args);  <span class="comment">//执行目标类的方法</span></span><br><span class="line">myAspect.after();</span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">}</span><br><span class="line">});</span><br><span class="line"><span class="keyword">return</span> proxService;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo01</span><span class="params">()</span></span>{</span><br><span class="line">UserService userService = MyBeanFactory.createService();</span><br><span class="line">userService.addUser();</span><br><span class="line">userService.updateUser();</span><br><span class="line">userService.deleteUser();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="CGLIB字节码增强"><a href="#CGLIB字节码增强" class="headerlink" title="CGLIB字节码增强"></a>CGLIB字节码增强</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactory</span> </span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserServiceImpl <span class="title">createService</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">final</span> UserServiceImpl userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line"><span class="keyword">final</span> MyAspect myAspect = <span class="keyword">new</span> MyAspect();</span><br><span class="line"><span class="comment">//代理类 ，采用cglib，底层创建目标类的子类</span></span><br><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();     <span class="comment">//核心类</span></span><br><span class="line">enhancer.setSuperclass(userService.getClass());     <span class="comment">//确定父类</span></span><br><span class="line">enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor(){       <span class="comment">//设置回调函数</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">myAspect.before();</span><br><span class="line">Object obj = method.invoke(userService, args);  <span class="comment">//执行目标方法</span></span><br><span class="line">methodProxy.invokeSuper(proxy, args);   </span><br><span class="line">myAspect.after();</span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">}</span><br><span class="line">});</span><br><span class="line">UserServiceImpl proxService = (UserServiceImpl) enhancer.create();</span><br><span class="line"><span class="keyword">return</span> proxService;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h2><ul><li>前置通知 MethodBeforeAdvice 在目标方法执行前实施增强</li><li>后置通知 AfterReturningAdvice 在目标方法执行后实施增强</li><li>环绕通知 MethodInterceptor 在目标方法执行前后实施增强</li><li>异常抛出通知 ThrowsAdvice 在方法抛出异常后实施增强</li><li>引介通知 IntroductionInterceptor 在目标类中添加一些新的方法和属性</li></ul><p>其中环绕通知必须手动执行目标方法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>{</span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    <span class="comment">//执行目标方法</span></span><br><span class="line">    <span class="comment">//后置通知</span></span><br><span class="line">}<span class="keyword">catch</span>(){</span><br><span class="line">    <span class="comment">//抛出异常通知</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="Spring代理：半自动（了解）"><a href="#Spring代理：半自动（了解）" class="headerlink" title="Spring代理：半自动（了解）"></a>Spring代理：半自动（了解）</h2><p>让spring 创建代理对象，从spring容器中手动的获取代理对象。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 切面类中确定通知，需要实现不同接口，接口就是规范，从而就确定方法名称。</span></span><br><span class="line"><span class="comment"> *      MethodInterceptor:环绕通知</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>{</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">System.out.println(<span class="string">"before...."</span>);</span><br><span class="line"><span class="comment">//执行目标方法</span></span><br><span class="line">Object obj = mi.proceed();</span><br><span class="line">System.out.println(<span class="string">"after...."</span>);</span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment"><!-- Spring的配置文件applicationContext.xml --></span></span><br><span class="line"><span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userServiceId"</span> <span class="attr">class</span>=<span class="string">"com.xxx.service.impl.UserServiceImpl"</span>></span><span class="tag"><!--<span class="name"-->bean</span>></span><br><span class="line"><span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myAspectId"</span> <span class="attr">class</span>=<span class="string">"com.xxx.aspect.MyAspect"</span>></span><span class="tag"><!--<span class="name"-->bean</span>></span><br><span class="line">   <span class="comment"><!-- ProxyFactoryBean：用于创建代理工程bean生成特殊代理对象</span></span><br><span class="line"><span class="comment">           需要注入接口，以及目标类，切面类</span></span><br><span class="line"><span class="comment">   --></span></span><br><span class="line"><span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"proxyServiceId"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.ProxyFactoryBean"</span>></span></span><br><span class="line"><span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interfaces"</span> <span class="attr">value</span>=<span class="string">"com.xxx.service.UserService"</span>></span><span class="tag"><!--<span class="name"-->property</span>></span><br><span class="line"><span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span> <span class="attr">ref</span>=<span class="string">"userServiceId"</span>></span><span class="tag"><!--<span class="name"-->property</span>></span><br><span class="line"><span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span> <span class="attr">value</span>=<span class="string">"myAspectId"</span>></span><span class="tag"><!--<span class="name"-->property</span>></span><br><span class="line"><span class="tag"><!--<span class="name"-->bean</span>></span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo01</span><span class="params">()</span></span>{</span><br><span class="line">String xmlPath = <span class="string">"xxx/applicationContext.xml"</span>;</span><br><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(xmlPath);</span><br><span class="line"><span class="comment">//获得代理类</span></span><br><span class="line">UserService userService = (UserService) applicationContext.getBean(<span class="string">"proxyServiceId"</span>);</span><br><span class="line">userService.addUser();</span><br><span class="line">userService.updateUser();</span><br><span class="line">userService.deleteUser();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="Spring-AOP编程：全自动（掌握）"><a href="#Spring-AOP编程：全自动（掌握）" class="headerlink" title="Spring AOP编程：全自动（掌握）"></a>Spring AOP编程：全自动（掌握）</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userServiceId"</span> <span class="attr">class</span>=<span class="string">"com.xxx.service.impl.UserServiceImpl"</span>></span><span class="tag"><!--<span class="name"-->bean</span>></span><br><span class="line"><span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myAspectId"</span> <span class="attr">class</span>=<span class="string">"com.xxx.aspect.MyAspect"</span>></span><span class="tag"><!--<span class="name"-->bean</span>></span><br><span class="line"><span class="tag"><<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>></span></span><br><span class="line"><span class="tag"><<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* com.xxx.*.*(..))"</span> <span class="attr">id</span>=<span class="string">"myPointCut"</span>/></span></span><br><span class="line"><span class="comment"><!-- 特殊的切面：只有一个通知和一个切入点 --></span></span><br><span class="line"><span class="tag"><<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"myAspectId"</span> <span class="attr">pointcut-ref</span>=<span class="string">"myPointCut"</span>/></span></span><br><span class="line"><span class="tag"><!--<span class="name"-->aop:config</span>></span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo01</span><span class="params">()</span></span>{</span><br><span class="line">String xmlPath = <span class="string">"xxx/applicationContext.xml"</span>;</span><br><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(xmlPath);</span><br><span class="line"></span><br><span class="line">UserService userService = (UserService) applicationContext.getBean(<span class="string">"userServiceId"</span>);</span><br><span class="line">userService.addUser();</span><br><span class="line">userService.updateUser();</span><br><span class="line">userService.deleteUser();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="基于AspectJ"><a href="#基于AspectJ" class="headerlink" title="基于AspectJ"></a>基于AspectJ</h2><p>AspectJ是一个AOP框架</p><h3 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式 *"></a>切入点表达式 *</h3><p>execution(* com . xxx . * . * ( .. ))<br>excecution(修饰符（省略） 返回值 包.类.方法名(参数) throws 异常)<br>*代表任意值</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>{</span><br><span class="line">    <span class="comment">//环绕通知</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">myAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable</span>{</span><br><span class="line">System.out.println(<span class="string">"before..."</span>);</span><br><span class="line"><span class="comment">//执行目标方法</span></span><br><span class="line">Object obj = joinPoint.proceed();</span><br><span class="line">System.out.println(<span class="string">"after..."</span>);</span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userServiceId"</span> <span class="attr">class</span>=<span class="string">"com.itheima.d_aspect.a_xml.UserServiceImpl"</span>></span><span class="tag"><!--<span class="name"-->bean</span>></span><br><span class="line"><span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myAspectId"</span> <span class="attr">class</span>=<span class="string">"com.itheima.d_aspect.a_xml.MyAspect"</span>></span><span class="tag"><!--<span class="name"-->bean</span>></span><br><span class="line"><span class="tag"><<span class="name">aop:config</span>></span></span><br><span class="line"><span class="tag"><<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"myAspectId"</span>></span></span><br><span class="line"><span class="tag"><<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* com.xxx.service.impl.UserServiceImpl.*(..))"</span> <span class="attr">id</span>=<span class="string">"myPointCut"</span>/></span></span><br><span class="line"><span class="comment"><!-- 其他通知类似 --></span></span><br><span class="line"><span class="tag"><<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">"myAround"</span> <span class="attr">pointcut-ref</span>=<span class="string">"myPointCut"</span>/></span></span><br><span class="line"><span class="tag"><!--<span class="name"-->aop:config</span>></span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;AOP概述&quot;&gt;&lt;a href=&quot;#AOP概述&quot; class=&quot;headerlink&quot; title=&quot;AOP概述&quot;&gt;&lt;/a&gt;AOP概述&lt;/h1&gt;&lt;h2 id=&quot;什么是-AOP&quot;&gt;&lt;a href=&quot;#什么是-AOP&quot; 
      
    
    </summary>
    
    
      <category term="框架" scheme="https://qihuang7.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="spring" scheme="https://qihuang7.top/categories/%E6%A1%86%E6%9E%B6/spring/"/>
    
    
      <category term="基础" scheme="https://qihuang7.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="SSM" scheme="https://qihuang7.top/tags/SSM/"/>
    
      <category term="spring" scheme="https://qihuang7.top/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：圆圈中最后剩下的数字</title>
    <link href="https://qihuang7.top/2020/04/04/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://qihuang7.top/2020/04/04/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2020-04-04T12:37:29.000Z</published>
    <updated>2020-04-04T12:40:28.776Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="62-圆圈中最后剩下的数字"><a href="#62-圆圈中最后剩下的数字" class="headerlink" title="62.圆圈中最后剩下的数字"></a>62.圆圈中最后剩下的数字</h1><p><strong>难度：</strong> 简单</p><p><strong>题目：</strong> 0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p><p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p><hr><p><strong>示例1：输入：</strong> n = 5，m = 3    <strong>输出：</strong> 3</p><p><strong>示例2：输入：</strong> n = 10，m = 17    <strong>输出：</strong> 2</p><hr><p><strong>限制：</strong> </p><ul><li>1 <= n <=10^5     </li><li>1 <= m <=10^6</li></ul><p><strong>解题1 模拟做法</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>{</span><br><span class="line">        ArrayList<integer> list = <span class="keyword">new</span> ArrayList<>(n);</integer></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < n; i++) {</span><br><span class="line">            list.add(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n > <span class="number">1</span>) {</span><br><span class="line">            idx = (idx + m - <span class="number">1</span>) % n;</span><br><span class="line">            list.remove(idx);</span><br><span class="line">            n--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>思路</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n=5,m=3,idx=00 1 2 3 4</span><br><span class="line">n=5idx=(0+3-1)%5=2%5=2remove(2)0 1 3 4</span><br><span class="line">n=4idx=(2+3-1)%4=4%4=0remove(0)1 3 4</span><br><span class="line">n=3idx=(0+3-1)%3=2%3=2remove(2)1 3</span><br><span class="line">n=2idx=(2+3-1)%2=4%2=0remove(0)3</span><br><span class="line">n=1</span><br></pre></td></tr></tbody></table></figure></div><p><strong>题解2 数学方法</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 最后一轮剩下2个人，所以从2开始反推</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i <= n; i++) {</span><br><span class="line">            ans = (ans + m) % i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;62-圆圈中最后剩下的数字&quot;&gt;&lt;a href=&quot;#62-圆圈中最后剩下的数字&quot; class=&quot;headerlink&quot; title=&quot;62.圆圈中最后剩下的数字&quot;&gt;&lt;/a&gt;62.圆圈中最后剩下的数字&lt;/h1&gt;&lt;p&gt;&lt;
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://qihuang7.top/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://qihuang7.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>java多线程基础（四）：线程的状态及主要转化方法</title>
    <link href="https://qihuang7.top/2020/04/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%8A%E4%B8%BB%E8%A6%81%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/"/>
    <id>https://qihuang7.top/2020/04/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%8A%E4%B8%BB%E8%A6%81%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/</id>
    <published>2020-04-04T11:27:53.000Z</published>
    <updated>2020-04-04T15:35:17.553Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="第四章-Java线程的状态及主要转化方法"><a href="#第四章-Java线程的状态及主要转化方法" class="headerlink" title="第四章 Java线程的状态及主要转化方法"></a>第四章 Java线程的状态及主要转化方法</h1><h2 id="操作系统中的线程状态转换"><a href="#操作系统中的线程状态转换" class="headerlink" title="操作系统中的线程状态转换"></a>操作系统中的线程状态转换</h2><p>线程被视为轻量级线程，所有操作系统 <strong>线程的状态和进程的状态是一致的</strong></p><p><a href="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.PNG" data-fancybox="group" data-caption="操作系统线程的状态" class="fancybox"><img alt="操作系统线程的状态" title="操作系统线程的状态" data-src="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.PNG" class="lazyload"></a></p><p>线程主要有以下三个状态：</p><ul><li>就绪状态(ready)：线程正在等待使用CPU，经调度程序调用之后可进入running状态</li><li>执行状态(running)：线程正在使用CPU</li><li>等待状态(waiting)：线程经过等待事件的调用或者正在等待其他资源（如I/O）。</li></ul><h2 id="线程的六个状态："><a href="#线程的六个状态：" class="headerlink" title="线程的六个状态："></a>线程的六个状态：</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread.State 源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State {</span><br><span class="line">    NEW,</span><br><span class="line">    RUNNABLE,       </span><br><span class="line">    BLOCKED,        <span class="comment">//阻塞状态</span></span><br><span class="line">    WAITING,        <span class="comment">//等待状态</span></span><br><span class="line">    TIMED_WAITING,  <span class="comment">//</span></span><br><span class="line">    超时等待状态</span><br><span class="line">    TERMINATED;     <span class="comment">//终止状态，此时线程已执行完毕</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="start-的两个问题"><a href="#start-的两个问题" class="headerlink" title="start()的两个问题"></a>start()的两个问题</h3><blockquote><p>反复调用同一个线程的start()方法是否可行？<br>假如一个线程执行完毕（此时处于TERMINATED状态），再次调用这个线程的start()方法是否可行？</p></blockquote><p>首先看一下start()的源码</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">    group.add(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">if</span> (!started) {</span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable ignore) {</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>在start()内部有一个threadStatus变量，如果不等于0调用start()会直接抛出异常。</p><blockquote><p>在调用一次start()之后，threadStatus的值会改变，此时再调start()方法会抛出异常  比如，threadStatus为2代表当前线程状态为TERMINATED</p></blockquote><h2 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h2><p><a href="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.PNG" data-fancybox="group" data-caption="线程状态转换图" class="fancybox"><img alt="线程状态转换图" title="线程状态转换图" data-src="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/java/basic/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.PNG" class="lazyload"></a></p><h3 id="BLOCKED与RUNNABLE状态转换"><a href="#BLOCKED与RUNNABLE状态转换" class="headerlink" title="BLOCKED与RUNNABLE状态转换"></a>BLOCKED与RUNNABLE状态转换</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">blockedTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    Thread a = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">          testMethod();</span><br><span class="line">        }</span><br><span class="line">    }, <span class="string">"a"</span>);</span><br><span class="line">    Thread b = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            testMethod();</span><br><span class="line">        }</span><br><span class="line">    }, <span class="string">"b"</span>);</span><br><span class="line">    a.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000L</span>); <span class="comment">// 需要注意这⾥main线程休眠了1000毫秒，⽽testMethod()⾥休眠了2000毫秒</span></span><br><span class="line">    b.start();</span><br><span class="line">    System.out.println(a.getName() + <span class="string">":"</span> + a.getState()); <span class="comment">// 输出TIMED_WAITING</span></span><br><span class="line">    System.out.println(b.getName() + <span class="string">":"</span> + b.getState()); <span class="comment">// 输出BLOCKED </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 同步⽅法争夺锁</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>处于Blocked状态的线程是因为在等待锁的释放。假如有两个线程a和b，a线程提前获得了锁并且暂未释放锁，此时b就处于Blocked状态。</p><p>在线程a执⾏run()调⽤testMethod()之后，线程a休眠了2000ms（注意这⾥是没有释放锁的），main线程休眠完毕，接着b线程执⾏的时候是争夺不到锁的</p><h3 id="WAITING与RUNNABLE状态转换"><a href="#WAITING与RUNNABLE状态转换" class="headerlink" title="WAITING与RUNNABLE状态转换"></a>WAITING与RUNNABLE状态转换</h3><ul><li>Object.wait()：<br>  调⽤wait()⽅法前线程必须持有对象的锁。<br>  线程调⽤wait()⽅法时，会释放当前的锁，直到有其他线程调⽤notify()/notifyAll()⽅法唤醒等待锁的线程。</li><li>Thread.join()：<br>调⽤join()⽅法不会释放锁，会⼀直等待当前线程执⾏完毕（转换为TERMINATED状态）。</li><li>LockSupport.park()：<br>除⾮获得调⽤许可，否则禁⽤当前线程进⾏线程调度。</li></ul><h3 id="TIMED-WAITING与RUNNABLE状态转换"><a href="#TIMED-WAITING与RUNNABLE状态转换" class="headerlink" title="TIMED_WAITING与RUNNABLE状态转换"></a>TIMED_WAITING与RUNNABLE状态转换</h3><p> TIMED_WAITING 与 WAITING 状态类似，只是 TIMED_WAITING 状态等待的时间是指定的</p><h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h3><blockquote><p>在某些情况下，我们在线程启动后发现并不需要它继续执⾏下去时，需要中断线程。⽬前在Java⾥还没有安全直接的⽅法来停⽌线程，但是Java提供了线程中断机制来处理需要中断线程的情况。<br><strong>线程中断机制是⼀种协作机制。</strong> 需要注意，通过中断操作并不能直接终⽌⼀个线程，⽽是 <strong>通知需要被中断的线程⾃⾏处理。</strong></p></blockquote><p>线程中断的几个方法：</p><ul><li>Thread.interrupt()：中断线程。这⾥的中断线程并不会⽴即停⽌线程，⽽是设置线程的中断状态为true（默认是flase）</li><li>Thread.interrupted()：测试当前线程是否被中断。</li><li>Thread.isInterrupted()：测试当前线程是否被中断。</li></ul></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;第四章-Java线程的状态及主要转化方法&quot;&gt;&lt;a href=&quot;#第四章-Java线程的状态及主要转化方法&quot; class=&quot;headerlink&quot; title=&quot;第四章 Java线程的状态及主要转化方法&quot;&gt;&lt;/a&gt;第
      
    
    </summary>
    
    
      <category term="java基础" scheme="https://qihuang7.top/categories/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="https://qihuang7.top/categories/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://qihuang7.top/tags/java/"/>
    
      <category term="基础" scheme="https://qihuang7.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="https://qihuang7.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>java多线程基础（三）：线程组和线程优先级</title>
    <link href="https://qihuang7.top/2020/04/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E7%BB%84%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <id>https://qihuang7.top/2020/04/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E7%BB%84%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7/</id>
    <published>2020-04-03T17:09:53.000Z</published>
    <updated>2020-04-04T15:35:18.537Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="第三章-线程组和线程优先级"><a href="#第三章-线程组和线程优先级" class="headerlink" title="第三章 线程组和线程优先级"></a>第三章 线程组和线程优先级</h1><h2 id="线程组（ThreadGroup）"><a href="#线程组（ThreadGroup）" class="headerlink" title="线程组（ThreadGroup）"></a>线程组（ThreadGroup）</h2><blockquote><p><strong>线程组可以对线程进行批量控制</strong><br>每个Thread必然存在于一个ThreadGroup中，<strong>Threa不能独立于ThreadGroup存在</strong>。<br>执行main()方法的线程名字是mian，如果在new Thread时没有显式指定，那么 <strong>默认将父线程</strong>（当前执⾏ new Thread的线程）的 <strong>线程组设置为自己的线程组</strong></p></blockquote><p>示例代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Thread testThread = <span class="keyword">new</span> Thread(() -> {</span><br><span class="line">            System.out.println(<span class="string">"testThread当前线程组名字："</span> +</span><br><span class="line">                Thread.currentThread().getThreadGroup().getName());</span><br><span class="line">            System.out.println(<span class="string">"testThread线程名字："</span> +</span><br><span class="line">                Thread.currentThread().getName());</span><br><span class="line">        });</span><br><span class="line">        testThread.start();</span><br><span class="line">        System.out.println(<span class="string">"执⾏main⽅法线程名字："</span> + Thread.currentThread().getName());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*输出结果：</span></span><br><span class="line"><span class="comment">    执⾏main⽅法线程名字：main</span></span><br><span class="line"><span class="comment">    testThread当前线程组名字：main</span></span><br><span class="line"><span class="comment">    testThread线程名字：Thread-0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure></div><p>ThreadGroup管理着它下⾯的Thread，ThreadGroup是⼀个标准的向下引⽤的树状结构，这样设计的原因是 <strong>防⽌”上级”线程被”下级”线程引用而无法有效地被GC（Garbage Collector垃圾收集器）回收</strong></p><h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><p>java中线程优先级可以制指定，范围是1~10，默认为5（有些操作系统只支持3级划分：低，中，高），java只是给操作系统一个优先级的 <strong>参考值</strong>，<strong>线程最终在操作系统的优先级是多少还是由操作系统决定</strong></p><p>使⽤Thread类的setPriority()⽅法来设定线程的优先级。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread a = <span class="keyword">new</span> Thread();</span><br><span class="line">a.setPriority(<span class="number">10</span>);</span><br></pre></td></tr></tbody></table></figure></div><h3 id="是不是可以在业务实现的时候采用这种方法来指定一些线程执行的先后顺序？"><a href="#是不是可以在业务实现的时候采用这种方法来指定一些线程执行的先后顺序？" class="headerlink" title="是不是可以在业务实现的时候采用这种方法来指定一些线程执行的先后顺序？"></a>是不是可以在业务实现的时候采用这种方法来指定一些线程执行的先后顺序？</h3><p>答案：No！java中的优先级并不是特别可靠，<strong>Java程序中对线程所设置的优先级只是给操作系统一个建议，操作系统不一定会采纳。而真正的调用顺序，是由操作系统的线程调度算法决定的。</strong></p><p>验证：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">T1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">super</span>.run();</span><br><span class="line">            System.out.println(String.format(<span class="string">"当前执⾏的线程是：%s，优先级：%d"</span>,</span><br><span class="line">                                Thread.currentThread().getName(),</span><br><span class="line">                                Thread.currentThread().getPriority()));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        IntStream.range(<span class="number">1</span>, <span class="number">10</span>).forEach(i -> {</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> T1());</span><br><span class="line">            thread.setPriority(i);</span><br><span class="line">            thread.start();</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*某次输出:</span></span><br><span class="line"><span class="comment">        当前执⾏的线程是：Thread-17，优先级：9 </span></span><br><span class="line"><span class="comment">        当前执⾏的线程是：Thread-1，优先级：1 </span></span><br><span class="line"><span class="comment">        当前执⾏的线程是：Thread-13，优先级：7 </span></span><br><span class="line"><span class="comment">        当前执⾏的线程是：Thread-11，优先级：6 </span></span><br><span class="line"><span class="comment">        当前执⾏的线程是：Thread-15，优先级：8 </span></span><br><span class="line"><span class="comment">        当前执⾏的线程是：Thread-7，优先级：4 </span></span><br><span class="line"><span class="comment">        当前执⾏的线程是：Thread-9，优先级：5 </span></span><br><span class="line"><span class="comment">        当前执⾏的线程是：Thread-3，优先级：2 </span></span><br><span class="line"><span class="comment">        当前执⾏的线程是：Thread-5，优先级：3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure></div><blockquote><p>Java提供一个 <strong>线程调度器</strong> 来监视处于 <strong>runnable</strong> 状态的线程。<br>线程的调度策略采用 <strong>抢占式</strong>，优先级高的线程比优先级低的线程会有更大的几率优先执行。<br><strong>优先级相同</strong> 的情况下按照 <strong>“先到先得”</strong> 的原则。</p></blockquote><h3 id="当线程和所在线程组的优先级不一致时会怎样？"><a href="#当线程和所在线程组的优先级不一致时会怎样？" class="headerlink" title="当线程和所在线程组的优先级不一致时会怎样？"></a>当线程和所在线程组的优先级不一致时会怎样？</h3><p><strong>答案：如果某个线程优先级⼤于线程所在线程组的最⼤优先级，那么该线程的优先 级将会失效，取⽽代之的是线程组的最⼤优先级。</strong></p><p>验证：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    ThreadGroup threadGroup = <span class="keyword">new</span> ThreadGroup(<span class="string">"t1"</span>);</span><br><span class="line">    threadGroup.setMaxPriority(<span class="number">6</span>);</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(threadGroup,<span class="string">"thread"</span>);</span><br><span class="line">    thread.setPriority(<span class="number">9</span>);</span><br><span class="line">    System.out.println(<span class="string">"我是线程组的优先级"</span>+threadGroup.getMaxPriority());</span><br><span class="line">    System.out.println(<span class="string">"我是线程的优先级"</span>+thread.getPriority());</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 输出：      </span></span><br><span class="line"><span class="comment">        我是线程组的优先级6       </span></span><br><span class="line"><span class="comment">        我是线程的优先级6</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure></div><h3 id="守护线程（Daemon）"><a href="#守护线程（Daemon）" class="headerlink" title="守护线程（Daemon）"></a>守护线程（Daemon）</h3><p>守护线程默认的优先级比较低，如果所有的非守护线程结束，这个守护线程会自动结束。</p><p><strong>应用场景：</strong> 当所有非守护线程结束时，结束其余的子线程（自动关闭）自动关闭，就免去了还要继续关闭子线程的麻烦</p><p>可以通过Thread类的setDaemon（boolean on)来设置守护线程</p><h2 id="线程组的常用方法级数据结构"><a href="#线程组的常用方法级数据结构" class="headerlink" title="线程组的常用方法级数据结构"></a>线程组的常用方法级数据结构</h2><h3 id="线程组的常用方法"><a href="#线程组的常用方法" class="headerlink" title="线程组的常用方法"></a>线程组的常用方法</h3><ul><li>获取当前线程组的名字：<blockquote><p>Thread.currentThread().getThreadGroup().getName()</p></blockquote></li><li>复制线程组：<blockquote><p>Thread[] threads = new Thread[threadGroup.activeCount()];<br>TheadGroup threadGroup = new ThreadGroup();<br>threadGroup.enumerate(threads);</p></blockquote></li><li>线程组统一异常处理<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadGroupDemo</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        ThreadGroup threadGroup1 = <span class="keyword">new</span> ThreadGroup(<span class="string">"group1"</span>) {</span><br><span class="line">            <span class="comment">// 继承ThreadGroup并重新定义以下⽅法</span></span><br><span class="line">            <span class="comment">// 在线程成员抛出unchecked exception</span></span><br><span class="line">            <span class="comment">// 会执⾏此⽅法</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>{</span><br><span class="line">                System.out.println(t.getName() + <span class="string">": "</span> + e.getMessage());</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">        <span class="comment">// 这个线程是threadGroup1的⼀员</span></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(threadGroup1, <span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="comment">// 抛出unchecked异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"测试异常"</span>);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        thread1.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="线程组的数据结构"><a href="#线程组的数据结构" class="headerlink" title="线程组的数据结构"></a>线程组的数据结构</h3>线程组可以包含其他的线程组，不仅仅是线程 </li></ul><p>总结来说， <strong>线程组是⼀个树状的结构</strong> ，每个线程组下⾯可以有多个线程或者线程 组。线程组可以起到 <strong>统⼀控制线程的优先级</strong> 和 <strong>检查线程的权限</strong> 的作⽤。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadGroup</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//===========TheadGroup源码中的成员变量============</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup parent; <span class="comment">// ⽗亲ThreadGroup</span></span><br><span class="line">    String name; <span class="comment">// ThreadGroupr 的名称</span></span><br><span class="line">    <span class="keyword">int</span> maxPriority; <span class="comment">// 线程最⼤优先级</span></span><br><span class="line">    <span class="keyword">boolean</span> destroyed; <span class="comment">// 是否被销毁</span></span><br><span class="line">    <span class="keyword">boolean</span> daemon; <span class="comment">// 是否守护线程</span></span><br><span class="line">    <span class="keyword">boolean</span> vmAllowSuspension; <span class="comment">// 是否可以中断</span></span><br><span class="line">    <span class="keyword">int</span> nUnstartedThreads = <span class="number">0</span>; <span class="comment">// 还未启动的线程</span></span><br><span class="line">    <span class="keyword">int</span> nthreads; <span class="comment">// ThreadGroup中线程数⽬</span></span><br><span class="line">    Thread threads[]; <span class="comment">// ThreadGroup中的线程</span></span><br><span class="line">    <span class="keyword">int</span> ngroups; <span class="comment">// 线程组数⽬</span></span><br><span class="line">    ThreadGroup groups[]; <span class="comment">// 线程组数组 </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//===========TheadGroup源码中的构造函数============</span></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadGroup</span><span class="params">()</span> </span>{ </span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">"system"</span>;</span><br><span class="line">        <span class="keyword">this</span>.maxPriority = Thread.MAX_PRIORITY;</span><br><span class="line">        <span class="keyword">this</span>.parent = <span class="keyword">null</span>; </span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 默认是以当前ThreadGroup传⼊作为parent ThreadGroup，新线程组的⽗线程组是⽬前正在运⾏线</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadGroup</span><span class="params">(String name)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>(Thread.currentThread().getThreadGroup(), name);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadGroup</span><span class="params">(ThreadGroup parent, String name)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>(checkParentAccess(parent), parent, name);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 私有构造函数，主要的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadGroup</span><span class="params">(Void unused, ThreadGroup parent, String name)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.maxPriority = parent.maxPriority;</span><br><span class="line">        <span class="keyword">this</span>.daemon = parent.daemon;</span><br><span class="line">        <span class="keyword">this</span>.vmAllowSuspension = parent.vmAllowSuspension;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        parent.add(<span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>第三个构造函数中调用了checkParentAccess方法，判断当前运⾏的线程是否具有修改线程组的权限</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;第三章-线程组和线程优先级&quot;&gt;&lt;a href=&quot;#第三章-线程组和线程优先级&quot; class=&quot;headerlink&quot; title=&quot;第三章 线程组和线程优先级&quot;&gt;&lt;/a&gt;第三章 线程组和线程优先级&lt;/h1&gt;&lt;h2 
      
    
    </summary>
    
    
      <category term="java基础" scheme="https://qihuang7.top/categories/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="https://qihuang7.top/categories/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://qihuang7.top/tags/java/"/>
    
      <category term="基础" scheme="https://qihuang7.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="https://qihuang7.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="优先级" scheme="https://qihuang7.top/tags/%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：用两个栈实现队列</title>
    <link href="https://qihuang7.top/2020/04/03/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%94%A8%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
    <id>https://qihuang7.top/2020/04/03/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E7%94%A8%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</id>
    <published>2020-04-03T14:12:52.000Z</published>
    <updated>2020-04-04T16:52:29.387Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225.用队列实现栈"></a>225.用队列实现栈</h1><p>使用队列实现栈的下列操作：</p><ul><li>push(x) – 元素 x 入栈</li><li>pop() – 移除栈顶元素</li><li>top() – 获取栈顶元素</li><li>empty() – 返回栈是否为空</li></ul><p><strong>注意:</strong></p><ul><li>你只能使用队列的基本操作– 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。</li><li>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li><li>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</li></ul><h2 id="官方题解：（两个队列，-压入-O-n-，-弹出-O-1-）"><a href="#官方题解：（两个队列，-压入-O-n-，-弹出-O-1-）" class="headerlink" title="官方题解：（两个队列， 压入 - O(n)， 弹出 - O(1)）"></a>官方题解：（两个队列， 压入 - O(n)， 弹出 - O(1)）</h2><h3 id="压入（push）"><a href="#压入（push）" class="headerlink" title="压入（push）"></a>压入（push）</h3><p>接下来介绍的算法让每一个新元素从 q2 入队，同时把这个元素作为栈顶元素保存。当 q1 非空（也就是栈非空），我们让 q1 中所有的元素全部出队，再将出队的元素从 q2 入队。通过这样的方式，新元素（栈中的栈顶元素）将会在 q2 的前端。我们通过将 q1， q2 互相交换的方式来避免把 q2 中的元素往 q1 中拷贝。</p><p><a href="https://pic.leetcode-cn.com/1acd10c255534e86719cf83b07f294c76967687c52db3ec44367d0cb7c45483e-file_1561370741978" data-fancybox="group" data-caption="push压入" class="fancybox"><img alt="push压入" title="push压入" data-src="https://pic.leetcode-cn.com/1acd10c255534e86719cf83b07f294c76967687c52db3ec44367d0cb7c45483e-file_1561370741978" class="lazyload"></a></p><p><strong>复杂度分析</strong></p><ul><li>*<em>时间复杂度：O(n)  *</em><br>算法会让 q1 出队 n 个元素，同时入队 n+1 个元素到 q2。这个过程会产生 2n+1 步操作，同时链表中 插入 操作和 移除 操作的时间复杂度为 O(1)，因此时间复杂度为 O(n)。</li><li><strong>空间复杂度：O(1)</strong></li></ul><h3 id="弹出（pop）"><a href="#弹出（pop）" class="headerlink" title="弹出（pop）"></a>弹出（pop）</h3><p>直接让 q1 中元素出队，同时将出队后的 q1 中的队首元素作为栈顶元素保存。</p><p><a href="https://pic.leetcode-cn.com/fc27d76b78bbe094f6912a0aa56dee5f8e618a4f04834ab043eb39ecb2e0cc93-file_1561370741978" data-fancybox="group" data-caption="pop弹出" class="fancybox"><img alt="pop弹出" title="pop弹出" data-src="https://pic.leetcode-cn.com/fc27d76b78bbe094f6912a0aa56dee5f8e618a4f04834ab043eb39ecb2e0cc93-file_1561370741978" class="lazyload"></a></p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(1)</li><li>空间复杂度：O(1)</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> Queue<integer> q1 = <span class="keyword">new</span> LinkedList<>();;</integer></span><br><span class="line">    <span class="keyword">private</span> Queue<integer> q2 = <span class="keyword">new</span> LinkedList<>();</integer></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>{</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/** 压栈 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">        q2.add(x);</span><br><span class="line">        top = x;</span><br><span class="line">        <span class="keyword">while</span> (!q1.isEmpty()) {                </span><br><span class="line">            q2.add(q1.remove());</span><br><span class="line">        }</span><br><span class="line">        Queue<integer> temp = q1;</integer></span><br><span class="line">        q1 = q2;</span><br><span class="line">        q2 = temp;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/** 出栈 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        q1.remove();</span><br><span class="line">        <span class="keyword">int</span> res = top;</span><br><span class="line">        <span class="keyword">if</span> (!q1.isEmpty()) {</span><br><span class="line">            top = q1.peek();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/** 获取栈顶元素 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> q1.isEmpty();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;225-用队列实现栈&quot;&gt;&lt;a href=&quot;#225-用队列实现栈&quot; class=&quot;headerlink&quot; title=&quot;225.用队列实现栈&quot;&gt;&lt;/a&gt;225.用队列实现栈&lt;/h1&gt;&lt;p&gt;使用队列实现栈的下列操作：
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://qihuang7.top/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://qihuang7.top/tags/leetcode/"/>
    
      <category term="栈" scheme="https://qihuang7.top/tags/%E6%A0%88/"/>
    
      <category term="队列" scheme="https://qihuang7.top/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：比较含退格的字符串</title>
    <link href="https://qihuang7.top/2020/04/03/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://qihuang7.top/2020/04/03/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-04-03T10:52:29.000Z</published>
    <updated>2020-04-03T10:58:55.268Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="844-比较含退格的字符串"><a href="#844-比较含退格的字符串" class="headerlink" title="844.比较含退格的字符串"></a>844.比较含退格的字符串</h1><p><strong>难度：</strong> 简单</p><p><strong>题目：</strong> 给定 S 和 T两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。</p><p><strong>示例1</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：S = "ab#c", T = "ad#c"</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “ac”。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例2</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：S = "ab##", T = "c#d#"</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “”。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例3</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：S = "a##c", T = "#a#c"</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “c”。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例4</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：S = "a#c", T = "b"</span><br><span class="line">输出：false</span><br><span class="line">解释：S 会变成 “c”，但 T 仍然是 “b”。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>提示：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 <= S.length <= 200</span><br><span class="line">1 <= T.length <= 200</span><br><span class="line">S 和 T 只含有小写字母以及字符 '#'。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>我的题解</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backspaceCompare</span><span class="params">(String S, String T)</span> </span>{</span><br><span class="line">        <span class="keyword">char</span>[] s = S.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] t = T.toCharArray();</span><br><span class="line">        Stack<character> stack1 = <span class="keyword">new</span> Stack<>();</character></span><br><span class="line">        Stack<character> stack2 = <span class="keyword">new</span> Stack<>();</character></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < s.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> ((<span class="string">'#'</span> ==s[i])){</span><br><span class="line">                <span class="keyword">if</span> (!stack1.isEmpty()) {</span><br><span class="line">                    stack1.pop();</span><br><span class="line">                }</span><br><span class="line">            }<span class="keyword">else</span> stack1.push(s[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < t.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> ((<span class="string">'#'</span> ==t[i])){</span><br><span class="line">                <span class="keyword">if</span> (!stack2.isEmpty()) {</span><br><span class="line">                    stack2.pop();</span><br><span class="line">                }</span><br><span class="line">            }<span class="keyword">else</span> stack2.push(t[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> Arrays.equals(stack1.toArray(), stack2.toArray());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行结果：通过</span><br><span class="line">执行用时 :3 ms</span><br><span class="line">内存消耗 :38.1 MB</span><br></pre></td></tr></tbody></table></figure></div><p><strong>官方题解</strong><br><strong>思想</strong><br>使用 build(S) 和 build(T) 构造去除了退格符和被删除字符后的字符串，然后比较它们是否相等。</p><p><strong>算法</strong><br>在 build(S) 中，使用栈存储每次输入的字符。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backspaceCompare</span><span class="params">(String S, String T)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> build(S).equals(build(T));</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">build</span><span class="params">(String S)</span> </span>{</span><br><span class="line">        Stack<character> ans = <span class="keyword">new</span> Stack();</character></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: S.toCharArray()) {</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">'#'</span>)</span><br><span class="line">                ans.push(c);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!ans.empty())</span><br><span class="line">                ans.pop();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(ans);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行结果：通过</span><br><span class="line">执行用时 :4 ms</span><br><span class="line">内存消耗 :38 MB</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;844-比较含退格的字符串&quot;&gt;&lt;a href=&quot;#844-比较含退格的字符串&quot; class=&quot;headerlink&quot; title=&quot;844.比较含退格的字符串&quot;&gt;&lt;/a&gt;844.比较含退格的字符串&lt;/h1&gt;&lt;p&gt;&lt;
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://qihuang7.top/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://qihuang7.top/tags/leetcode/"/>
    
      <category term="栈" scheme="https://qihuang7.top/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>java多线程基础（二）：入门类和接口</title>
    <link href="https://qihuang7.top/2020/04/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%85%A5%E9%97%A8%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/"/>
    <id>https://qihuang7.top/2020/04/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%85%A5%E9%97%A8%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/</id>
    <published>2020-04-03T10:43:53.000Z</published>
    <updated>2020-04-04T15:35:01.984Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="第⼆章-Java多线程⼊⻔类和接⼝"><a href="#第⼆章-Java多线程⼊⻔类和接⼝" class="headerlink" title="第⼆章 Java多线程⼊⻔类和接⼝"></a>第⼆章 Java多线程⼊⻔类和接⼝</h1><h2 id="Thread类和Runnable接口"><a href="#Thread类和Runnable接口" class="headerlink" title="Thread类和Runnable接口"></a>Thread类和Runnable接口</h2><p>实现“线程”类的两种方式</p><ul><li>继承Thread类，重写run方法</li><li>实现Runnable接口的run方法</li></ul><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Thread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        myThread.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"MyThread"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>调用start()方法后，该线程才算启动！</strong></p><blockquote><p>注意不可多次调⽤start()⽅法。在第⼀次调⽤start()⽅法后，再次调⽤start()<br>⽅法会抛出异常。</p></blockquote><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"MyThread"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="Thread类构造方法"><a href="#Thread类构造方法" class="headerlink" title="Thread类构造方法"></a>Thread类构造方法</h3><p>Thread 类是⼀个 Runnable 接⼝的实现类<br>实际情况下，我们⼤多是直接调⽤下⾯两个构造⽅法：</p><blockquote><p>Thread(Runnable target)<br>Thread(Runnable target, String name)</p></blockquote><p><strong>target</strong>：指定要执⾏的任务；<br><strong>name</strong>：线程的名字，多个线程的名字是可以重复的。默认是 “Thread-“+nextThreadNum()</p><h3 id="Thread类的几个常用方法："><a href="#Thread类的几个常用方法：" class="headerlink" title="Thread类的几个常用方法："></a>Thread类的几个常用方法：</h3><ul><li>currentThread()：静态⽅法，返回对当前正在执⾏的线程对象的引⽤；</li><li>start()：开始执⾏线程的⽅法，java虚拟机会调⽤线程内的run()⽅法；</li><li>yield()：yield在英语⾥有放弃的意思，同样，这⾥的yield()指的是<strong>当前线程愿意让出对当前处理器的占⽤</strong>。这⾥需要注意的是，就算当前线程调⽤了yield()⽅法，程序在调度的时候，也还有可能继续运⾏这个线程的；</li><li>sleep()：静态⽅法，使当前线程睡眠⼀段时间；</li><li>join()：使当前线程等待另⼀个线程执⾏完毕之后再继续执⾏，内部调⽤的是Object类的wait⽅法实现的；</li></ul><h3 id="Thread类与Runnable接口的比较："><a href="#Thread类与Runnable接口的比较：" class="headerlink" title="Thread类与Runnable接口的比较："></a>Thread类与Runnable接口的比较：</h3><ul><li>由于Java“单继承，多实现”的特性，Runnable接⼝使⽤起来⽐Thread更灵活。</li><li>Runnable接⼝出现更符合⾯向对象，将线程单独进⾏对象的封装。</li><li>Runnable接⼝出现，降低了线程对象和线程任务的耦合性。 </li><li>如果使⽤线程时不需要使⽤Thread类的诸多⽅法，显然使⽤Runnable接⼝更 为轻量。</li></ul><p>所以，我们通常优先使⽤“<strong>实现 Runnable接⼝</strong>”这种⽅式来⾃定义线程类。</p><h2 id="Callable、Future与FutureTask"><a href="#Callable、Future与FutureTask" class="headerlink" title="Callable、Future与FutureTask"></a>Callable、Future与FutureTask</h2><p>使用Runnable和Thread来创建一个新的线程有一个弊端，就<strong>是run方法是没有返回值的</strong>。而有时候我们<strong>希望开启一个线程去执行一个任务，并且这个任务执行完成后有一个返回值。</strong><br>JDK提供了Callable接口与Future类为我们解决这个问题，这也是所谓的“异步模型”</p><h3 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h3><p>Callable与Runnable类似，同样是只有一个抽象方法的函数式接口。不同的式Callable提供的方法是有返回值的，而且支持泛型.源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span><<span class="title">V</span>> </span>{</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>Callable ⼀般是配合线程池⼯具 ExecutorService 来使⽤的。</p><p>一个简单使用的demo：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ⾃定义Callable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span><<span class="title">Integer</span>></span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">// 模拟计算需要⼀秒</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">        <span class="comment">// 使⽤</span></span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">        Task task = <span class="keyword">new</span> Task();</span><br><span class="line">        Future<integer> result = executor.submit(task);</integer></span><br><span class="line">        <span class="comment">// 注意调⽤get⽅法会阻塞当前线程，直到得到结果。</span></span><br><span class="line">        <span class="comment">// 所以实际编码中建议使⽤可以设置超时时间的重载get⽅法。</span></span><br><span class="line">        System.out.println(result.get()); </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="Future接口与FutureTask类"><a href="#Future接口与FutureTask类" class="headerlink" title="Future接口与FutureTask类"></a>Future接口与FutureTask类</h3><p>FutureTask是Future接口的实现类。FutureTask 是 实现的 RunnableFuture 接⼝的，⽽ RunnableFuture 接⼝同时继承了 Runnable 接⼝ 和 Future 接⼝</p><p>实例代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ⾃定义Callable，与上⾯⼀样</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span><<span class="title">Integer</span>></span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">// 模拟计算需要⼀秒</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">        <span class="comment">// 使⽤</span></span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">        FutureTask<integer> futureTask = <span class="keyword">new</span> FutureTask<>(<span class="keyword">new</span> Task());</integer></span><br><span class="line">        executor.submit(futureTask);</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;第⼆章-Java多线程⼊⻔类和接⼝&quot;&gt;&lt;a href=&quot;#第⼆章-Java多线程⼊⻔类和接⼝&quot; class=&quot;headerlink&quot; title=&quot;第⼆章 Java多线程⼊⻔类和接⼝&quot;&gt;&lt;/a&gt;第⼆章 Java多线
      
    
    </summary>
    
    
      <category term="java基础" scheme="https://qihuang7.top/categories/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="https://qihuang7.top/categories/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://qihuang7.top/tags/java/"/>
    
      <category term="基础" scheme="https://qihuang7.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="https://qihuang7.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="https://qihuang7.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Spring基础（一）：控制反转IOC与依赖注入（DI）</title>
    <link href="https://qihuang7.top/2020/04/03/%E6%A1%86%E6%9E%B6/Spring%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%ACIOC%E4%B8%8E%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%88DI%EF%BC%89/"/>
    <id>https://qihuang7.top/2020/04/03/%E6%A1%86%E6%9E%B6/Spring%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%ACIOC%E4%B8%8E%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%88DI%EF%BC%89/</id>
    <published>2020-04-03T10:24:39.000Z</published>
    <updated>2020-04-04T15:34:35.338Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="IOC控制反转与DI依赖注入"><a href="#IOC控制反转与DI依赖注入" class="headerlink" title="IOC控制反转与DI依赖注入"></a>IOC控制反转与DI依赖注入</h1><p>IOC： Inversion of control 反转控制。 比如以前创建一个对象，需要自己主动new 一个对象，通过IOC，对象的创建交由Spring框架 创建，开发人员直接使用已经创建好的对象。</p><p>DI： Dependency Injection 依赖注入。 通过IOC创建对象的时候，可以注入字符串甚至其他对象。 比如DAO就会注入session factory.</p><p>通常IOC和DI是紧密结合，一起使用的 </p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> interface <span class="title">UserDao</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>{</span><br><span class="line">System.out.println(<span class="string">"uesrDao say hello world!"</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><!-- applicationContext配置文件</span></span><br><span class="line"><span class="comment">    <bean> 配置需要创建的对象</span></span><br><span class="line"><span class="comment">id ：用于之后从spring容器获得实例时使用的</span></span><br><span class="line"><span class="comment">class ：需要创建实例的全限定类名</span></span><br><span class="line"><span class="comment">--></span></span><br><span class="line"><span class="meta"><!--?xml version="1.0" encoding="UTF-8"?--></span></span><br><span class="line"><span class="tag"><<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-3.2.xsd"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"com.itheima.ioc.UserDaoImpl"</span>/></span></span><br><span class="line"><span class="tag"><!--<span class="name"-->beans</span>></span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestIoc</span> </span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">ApplicationContext applicationContext = </span><br><span class="line"><span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">UserDao userDao = (UserDao) applicationContext.getBean(<span class="string">"userDao"</span>);</span><br><span class="line">userDao.say();</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="依赖注入（DI：Dependency-Injection）"><a href="#依赖注入（DI：Dependency-Injection）" class="headerlink" title="依赖注入（DI：Dependency Injection）"></a>依赖注入（DI：Dependency Injection）</h2><p>依赖注入与控制反转的含义相同，只不过是从两个角度描述的同一个概念</p><ul><li>在使用Spring框架之后，对象的实例不再由调用者来创建，而是由Spring容器来创建，<strong>Spring容器会负责控制程序之间的关系，而不是由调用者的程序代码直接控制</strong>。这样，<strong>控制权由应用代码转移到了Spring</strong>，控制权发送了反转，这就是Spring的控制反转。</li><li>从Spring容器的角度来看，<strong>Spring容器负责将被依赖对象赋值给调用者的成员变量</strong>，这相当于调用者注入了它依赖的实例，这就是Spring的依赖注入。</li></ul><h3 id="实现方式："><a href="#实现方式：" class="headerlink" title="实现方式："></a>实现方式：</h3><p><strong>属性setter方法注入：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> interface <span class="title">UserService</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>{</span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>{</span><br><span class="line"><span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">}</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">this</span>.userDao.say();</span><br><span class="line">System.out.println(<span class="string">"userService say hello World!"</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>在配置文件applicationContext.xml中添加id为userService的Bean并将userDao注入</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><!--    <property> 用于进行属性注入</span></span><br><span class="line"><span class="comment">        name： bean的属性名，通过setter方法获得</span></span><br><span class="line"><span class="comment">            setBookDao ##> BookDao  ##> bookDao</span></span><br><span class="line"><span class="comment">        ref ：另一个bean的id值的引用</span></span><br><span class="line"><span class="comment">--></span></span><br><span class="line"><span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.itheima.ioc.UserServiceImpl"</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userDao"</span> <span class="attr">ref</span>=<span class="string">"userDao"</span>></span><span class="tag"><!--<span class="name"-->property</span>></span><br><span class="line"><span class="tag"><!--<span class="name"-->bean</span>></span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试DI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDI</span> </span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">ApplicationContext applicationContext = </span><br><span class="line"><span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">UserService userService = (UserService) applicationContext.getBean(<span class="string">"userService"</span>);</span><br><span class="line">userService.say();</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>构造方法注入：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>{</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.User"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"张三"</span>/></span></span><br><span class="line">    <span class="tag"><<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"21"</span>/></span>></span><br><span class="line"><span class="tag"><!--<span class="name"-->bean</span>></span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;IOC控制反转与DI依赖注入&quot;&gt;&lt;a href=&quot;#IOC控制反转与DI依赖注入&quot; class=&quot;headerlink&quot; title=&quot;IOC控制反转与DI依赖注入&quot;&gt;&lt;/a&gt;IOC控制反转与DI依赖注入&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="框架" scheme="https://qihuang7.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="spring" scheme="https://qihuang7.top/categories/%E6%A1%86%E6%9E%B6/spring/"/>
    
    
      <category term="基础" scheme="https://qihuang7.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="SSM" scheme="https://qihuang7.top/tags/SSM/"/>
    
      <category term="spring" scheme="https://qihuang7.top/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：和为s的连续正数序列</title>
    <link href="https://qihuang7.top/2020/04/02/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/"/>
    <id>https://qihuang7.top/2020/04/02/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</id>
    <published>2020-04-02T12:52:29.000Z</published>
    <updated>2020-04-03T10:35:02.336Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="和为s的连续正数序列"><a href="#和为s的连续正数序列" class="headerlink" title="和为s的连续正数序列"></a>和为s的连续正数序列</h1><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：target = 9<br>输出：[[2,3,4],[4,5]]</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：target = 15<br>输出：[[1,2,3,4,5],[4,5,6],[7,8]]</p></blockquote><h2 id="解题思路：-滑动窗口"><a href="#解题思路：-滑动窗口" class="headerlink" title="解题思路：(滑动窗口)"></a>解题思路：(滑动窗口)</h2><h3 id="什么是滑动窗口"><a href="#什么是滑动窗口" class="headerlink" title="什么是滑动窗口"></a>什么是滑动窗口</h3><p>滑动窗口可以看成数组中框起来的一个部分。在一些数组类题目中，我们可以用滑动窗口来观察可能的候选结果。当滑动窗口从数组的左边滑到了右边，我们就可以从所有的候选结果中找到最优的结果。</p><p>对于这道题来说，数组就是正整数序列 [1,2,3,…,n]。我们设滑动窗口的左边界为 i，右边界为 j，则滑动窗口框起来的是一个左闭右开区间 [i,j)。注意，为了编程的方便，滑动窗口一般表示成一个左闭右开区间。在一开始，i=1,j=1，滑动窗口位于序列的最左侧，窗口大小为零。</p><p><a href="https://pic.leetcode-cn.com/af4821c41d5b093e6a41ad5602208f9e7057cc1b002cd0053de71bc9a0e35b12.jpg" data-fancybox="group" data-caption="滑动窗口" class="fancybox"><img alt="滑动窗口" title="滑动窗口" data-src="https://pic.leetcode-cn.com/af4821c41d5b093e6a41ad5602208f9e7057cc1b002cd0053de71bc9a0e35b12.jpg" class="lazyload"></a></p><p>滑动窗口的重要性质是：<strong>窗口的左边界和右边界永远只能向右移动</strong>，而不能向左移动。这是为了保证滑动窗口的时间复杂度是 O(n)。如果左右边界向左移动的话，这叫做“回溯”，算法的时间复杂度就可能不止 O(n)。</p><p>在这道题中，我们关注的是滑动窗口中所有数的和。当滑动窗口的右边界向右移动时，也就是 j = j + 1，窗口中多了一个数字 j，窗口的和也就要加上 j。当滑动窗口的左边界向右移动时，也就是 i = i + 1，窗口中少了一个数字 i，窗口的和也就要减去 i。滑动窗口只有 右边界向右移动（扩大窗口） 和 左边界向右移动（缩小窗口） 两个操作，所以实际上非常简单。</p><p>要用滑动窗口解这道题，我们要回答两个问题：</p><ul><li>第一个问题，窗口何时扩大，何时缩小？</li><li>第二个问题，滑动窗口能找到全部的解吗？</li></ul><p>对于第一个问题，回答非常简单：</p><ul><li>当窗口的和<strong>小于 target</strong> 的时候，窗口的和需要增加，所以要扩大窗口，窗口的右边界向右移动</li><li>当窗口的和<strong>大于 target</strong> 的时候，窗口的和需要减少，所以要缩小窗口，窗口的左边界向右移动</li><li>当窗口的和恰好<strong>等于 target</strong> 的时候，我们需要记录此时的结果。设此时的窗口为 [i,j)，那么我们已经找到了一个 i 开头的序列，也是唯一一个 i 开头的序列，接下来需要找 i+1 开头的序列，所以窗口的左边界要向右移动</li></ul><p>对于第二个问题，我们可以稍微简单地证明一下：</p><p><a href="https://pic.leetcode-cn.com/728c705889a672d5a85709cb3fd157216bb1a41dc377dcc125818d9e18b8dd55.jpg" data-fancybox="group" data-caption="滑动窗口" class="fancybox"><img alt="滑动窗口" title="滑动窗口" data-src="https://pic.leetcode-cn.com/728c705889a672d5a85709cb3fd157216bb1a41dc377dcc125818d9e18b8dd55.jpg" class="lazyload"></a></p><p>我们一开始要找的是 1 开头的序列，只要窗口的和小于 target，窗口的右边界会一直向右移动。假设 1+2+⋯+8小于target，再加上一个 9之后， 发现 1+2+⋯+8+9又大于target了。这说明1开头的序列找不到解。此时滑动窗口的最右元素是 9。</p><p>接下来，我们需要找2开头的序列，我们发现，2+⋯+8 < 1+2+⋯+8 < target2。这说明 2 开头的序列至少要加到9。那么，我们只需要把原先1 ~ 9的滑动窗口的左边界向右移动，变成 2 ~ 9的滑动窗口，然后继续寻找。而右边界完全不需要向左移动。</p><p>以此类推，滑动窗口的左右边界都不需要向左移动，所以这道题用滑动窗口一定可以得到所有的解。<strong>时间复杂度是 O(n)。</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] findContinuousSequence(<span class="keyword">int</span> target) {</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>; <span class="comment">// 滑动窗口的左边界</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">1</span>; <span class="comment">// 滑动窗口的右边界</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">// 滑动窗口中数字的和</span></span><br><span class="line">        List<<span class="keyword">int</span>[]> res = <span class="keyword">new</span> ArrayList<>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i <= target / <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">if</span> (sum < target) {</span><br><span class="line">                <span class="comment">// 右边界向右移动</span></span><br><span class="line">                sum += j;</span><br><span class="line">                j++;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (sum > target) {</span><br><span class="line">                <span class="comment">// 左边界向右移动</span></span><br><span class="line">                sum -= i;</span><br><span class="line">                i++;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 记录结果</span></span><br><span class="line">                <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[j-i];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k < j; k++) {</span><br><span class="line">                    arr[k-i] = k;</span><br><span class="line">                }</span><br><span class="line">                res.add(arr);</span><br><span class="line">                <span class="comment">// 左边界向右移动</span></span><br><span class="line">                sum -= i;</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[res.size()][]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;和为s的连续正数序列&quot;&gt;&lt;a href=&quot;#和为s的连续正数序列&quot; class=&quot;headerlink&quot; title=&quot;和为s的连续正数序列&quot;&gt;&lt;/a&gt;和为s的连续正数序列&lt;/h1&gt;&lt;p&gt;输入一个正整数 targe
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://qihuang7.top/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://qihuang7.top/tags/leetcode/"/>
    
      <category term="数组" scheme="https://qihuang7.top/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之单例模式</title>
    <link href="https://qihuang7.top/2020/04/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://qihuang7.top/2020/04/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-02T12:07:41.000Z</published>
    <updated>2020-04-04T15:35:38.126Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="设计模式类型"><a href="#设计模式类型" class="headerlink" title="设计模式类型"></a>设计模式类型</h1><p><strong>设计模式分为三种类型，共23种：</strong></p><ol><li><strong>创建型模式：</strong> <strong>单例模式</strong>、抽象工厂模式、原型模式、建造者模式、<strong>工厂模式</strong></li><li><strong>结构型模式：</strong> 适配器模式、桥接模式、<strong>装饰模式</strong>、组合模式、外观模式、享元模式、<strong>代理模式</strong></li><li><strong>行为型模式：</strong> 模板方法模式、命令模式、访问者模式、迭代器模式、<strong>观察者模式</strong>、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式（责任链模式）<h1 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2>所谓类的单例模式，就是采取一定的方法保证在整个软件系统中，对某个类<strong>只能存在一个对象实例</strong> ,并且该类只提供一个取得其对象实例的方法（静态方法）。</li></ol><p>比如SessionFactory，它充当数据存储源的代理，并负责创建Session对象，SessionFactory并不是轻量级的，一般情况下，一个项目通常只需要一个SessionFactory就够，这就使用到了单例模式</p><h2 id="单例模式的八种实现方式："><a href="#单例模式的八种实现方式：" class="headerlink" title="单例模式的八种实现方式："></a>单例模式的八种实现方式：</h2><p>首先我们使用一个测试类，其中创建两个Singleton对象，通过比较这两个对象直接是否相等来判断是否为同一个对象</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>{</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>{</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">        Singleton instance2 = Singleton.getInstance();</span><br><span class="line">        System.out.println(instance == instance2);</span><br><span class="line">        System.out.println(<span class="string">"instance.hashCode="</span> + instance.hashCode() );</span><br><span class="line">        System.out.println(<span class="string">"instance2.hashCode="</span> + instance2.hashCode() ); </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="1-饿汉式（静态常量）"><a href="#1-饿汉式（静态常量）" class="headerlink" title="1.饿汉式（静态常量）"></a>1.饿汉式（静态常量）</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2.本类内部创建对象实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3.提供一个公有的静态方法，返回实例对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>优缺点说明：</strong>  </p><p>1）<strong>优点</strong>：写法简单，在类装载时完成实例化，<strong>避免了线程同步</strong><br>2）<strong>缺点</strong>：<strong>没有达到懒加载</strong> Lazy Loading的效果。如果从始至终没有使用该实例，<strong>可能会造成内存的浪费</strong></p><h3 id="2-饿汉式（静态代码块）"><a href="#2-饿汉式（静态代码块）" class="headerlink" title="2.饿汉式（静态代码块）"></a>2.饿汉式（静态代码块）</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2.本类内部创建对象实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3.提供一个公有的静态方法，返回实例对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>优缺点说明：</strong></p><p>优缺点和饿汉式静态常量一样，只是将类实例化的过程放在了静态代码块中，也是在类装载时执行静态代码块中的代码，初始化类的实例。</p><h3 id="3-懒汉式1（线程不安全）"><a href="#3-懒汉式1（线程不安全）" class="headerlink" title="3.懒汉式1（线程不安全）"></a>3.懒汉式1（线程不安全）</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供一个静态的共有方法，当使用到该方法时才去创建instance</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>优缺点说明：</strong></p><p>1）起到了<strong>懒加载</strong>的效果，但是只能在单线程下使用。<br>2）如果在多线程下，一个线程进入了if (instance == null) 判断语句，还没来得及往下执行，另一个线程也通过了这个判断语句，这时便<strong>会产生多个实例</strong>。所以<strong>在多线程环境下不可使用这种方式</strong></p><h3 id="4-懒汉式2（线程安全，同步方法）"><a href="#4-懒汉式2（线程安全，同步方法）" class="headerlink" title="4.懒汉式2（线程安全，同步方法）"></a>4.懒汉式2（线程安全，同步方法）</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><blockquote><p>关键字<strong>synchronized</strong>可以保证在同一时刻，只有一个线程可以执行某个方法或某个代码块，同时synchronized可以保证一个线程的变化可见（可见性）</p></blockquote><p><strong>优缺点说明：</strong><br>1）解决了线程不安全问题<br>2）效率太低。每个线程想获得实例时，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例直接return就好。</p><h3 id="5-懒汉式3（线程安全，同步代码块）"><a href="#5-懒汉式3（线程安全，同步代码块）" class="headerlink" title="5.懒汉式3（线程安全，同步代码块）"></a>5.懒汉式3（线程安全，同步代码块）</h3><p>这种方式本意是想对懒汉式2的改进，改为同步产生实例化的代码块<br>但是这种同步并不能起到线程同步的作用。跟懒汉式1一样可能会产生多个实例，故在此不做介绍。</p><h3 id="6-双重检查（解决线程安全与效率问题）"><a href="#6-双重检查（解决线程安全与效率问题）" class="headerlink" title="6.双重检查（解决线程安全与效率问题）"></a><strong>6.双重检查（解决线程安全与效率问题）</strong></h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供一个静态的公有方法，加入双重检查代码，解决线程安全问题，同时解决懒加载问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>{</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><blockquote><p>volatile 是一个类型修饰符。volatile的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略。  </p></blockquote><p><strong>优缺点说明：</strong></p><p>1）双重检查概念是多线程开发种常使用到的，如代码中所示，我们<strong>进行了两次if(instance == null)检查</strong>，<strong>实例化代码只用执行一次</strong>，后面再访问是，instance!=null直接return实例化对象，也避免的反复进行方法同步<br>2）<strong>线程安全，延迟加载，效率较高</strong></p><h3 id="7-静态内部类"><a href="#7-静态内部类" class="headerlink" title="7.静态内部类"></a>7.静态内部类</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>{ }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写一个静态内部类，该类中由一个静态属性Singleton</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span></span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>优缺点说明：</strong></p><p>1）采用类装载的机制来保证初始化实例时只有一个线程<br>2）类的静态属性只会在第一次加载类时初始化，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程时无法进入的</p><h3 id="8-枚举"><a href="#8-枚举" class="headerlink" title="8.枚举"></a>8.枚举</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Singleton{</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayOK</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"ok"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;设计模式类型&quot;&gt;&lt;a href=&quot;#设计模式类型&quot; class=&quot;headerlink&quot; title=&quot;设计模式类型&quot;&gt;&lt;/a&gt;设计模式类型&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;设计模式分为三种类型，共23种：&lt;/str
      
    
    </summary>
    
    
      <category term="java基础" scheme="https://qihuang7.top/categories/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="设计模式" scheme="https://qihuang7.top/categories/java%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="https://qihuang7.top/tags/java/"/>
    
      <category term="基础" scheme="https://qihuang7.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="设计模式" scheme="https://qihuang7.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：最小的k个数</title>
    <link href="https://qihuang7.top/2020/04/02/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/"/>
    <id>https://qihuang7.top/2020/04/02/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</id>
    <published>2020-04-02T11:03:17.000Z</published>
    <updated>2020-04-04T16:53:19.647Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="面试题40-最小的k个数"><a href="#面试题40-最小的k个数" class="headerlink" title="面试题40. 最小的k个数"></a>面试题40. 最小的k个数</h1><p><strong>难度：简单</strong></p><p>输入整数数组arr，找出其中最小的k个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><p><strong>示例1：</strong> </p><blockquote><p>输入：arr = [3,2,1], k = 2<br>输出：[1,2] 或者 [2,1]  </p></blockquote><p><strong>示例2：</strong> </p><blockquote><p>输入：arr = [0,1,2,1], k = 1<br>输出：[0]</p></blockquote><p><strong>限制：</strong></p><ul><li>0 <= k <= arr.length <= 10000</li><li>0 <= arr[i] <= 10000</li></ul><p><strong>我的解题：</strong></p><p>首先将数组arr从小到大排序，使用的排序算法不限（我使用的是插入排序），然后在声明一个长度为k的数组a，将排序后的数组arr一一赋值给a，最后返回a</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) {</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        sort(arr);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i < k;i++){</span><br><span class="line">            a[i]=arr[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i < arr.length;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j > <span class="number">0</span> && arr[j]<arr[j-<span class="number">1</arr[j-<span></span>];j--){<br><span class="line">                <span class="keyword">int</span> t = arr[j];</span><br><span class="line">                arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">                arr[j-<span class="number">1</span>] = t;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>执行结果：通过<br>执行用时 :180 ms<br>内存消耗 :41.7 MB  </p><p><strong>另一种解法：用快排最最最高效解决TopK问题</strong>  </p><p>注意找前 K 大/前 K 小问题不需要对整个数组进行 O(NlogN)O(NlogN)O(NlogN) 的排序！<br>例如本题，直接通过快排切分排好第 K小的数（下标为K-1），那么它左边的数就是比它小的另外 K-1 个数啦～</p><p>下面代码给出了详细的注释，没啥好啰嗦的，就是快排模版要记牢哈～</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) {</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || arr.length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 最后一个参数表示我们要找的是下标为k-1的数</span></span><br><span class="line">        <span class="keyword">return</span> quickSearch(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] quickSearch(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> k) {</span><br><span class="line">        <span class="comment">// 每快排切分1次，找到排序后下标为j的元素，如果j恰好等于k就返回j以及j左边所有的数；</span></span><br><span class="line">        <span class="keyword">int</span> j = partition(nums, lo, hi);</span><br><span class="line">        <span class="keyword">if</span> (j == k) {</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(nums, j + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 否则根据下标j与k的大小关系来决定继续切分左段还是右段。</span></span><br><span class="line">        <span class="keyword">return</span> j > k? quickSearch(nums, lo, j - <span class="number">1</span>, k): quickSearch(nums, j + <span class="number">1</span>, hi, k);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快排切分，返回下标j，使得比nums[j]小的数都在j的左边，比nums[j]大的数都在j的右边。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> v = nums[lo];</span><br><span class="line">        <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            <span class="keyword">while</span> (++i <= hi && nums[i] < v);</span><br><span class="line">            <span class="keyword">while</span> (--j >= lo && nums[j] > v);</span><br><span class="line">            <span class="keyword">if</span> (i >= j) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">int</span> t = nums[j];</span><br><span class="line">            nums[j] = nums[i];</span><br><span class="line">            nums[i] = t;</span><br><span class="line">        }</span><br><span class="line">        nums[lo] = nums[j];</span><br><span class="line">        nums[j] = v;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>快排切分时间复杂度分析：</strong> 因为我们是要找下标为k的元素，第一次切分的时候需要遍历整个数组 (0 ~ n) 找到了下标是 j 的元素，假如 k 比 j 小的话，那么我们下次切分只要遍历数组 (0~k-1)的元素就行啦，反之如果 k 比 j 大的话，那下次切分只要遍历数组 (k+1～n) 的元素就行啦，总之可以看作每次调用 partition 遍历的元素数目都是上一次遍历的 1/2，因此时间复杂度是 N + N/2 + N/4 + … + N/N = 2N, 因此时间复杂度是 <strong>O(N)。</strong></p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;面试题40-最小的k个数&quot;&gt;&lt;a href=&quot;#面试题40-最小的k个数&quot; class=&quot;headerlink&quot; title=&quot;面试题40. 最小的k个数&quot;&gt;&lt;/a&gt;面试题40. 最小的k个数&lt;/h1&gt;&lt;p&gt;&lt;st
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://qihuang7.top/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://qihuang7.top/tags/leetcode/"/>
    
      <category term="排序" scheme="https://qihuang7.top/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>java多线程基础（一）：进程与线程的基本概念</title>
    <link href="https://qihuang7.top/2020/04/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://qihuang7.top/2020/04/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2020-04-02T06:20:26.000Z</published>
    <updated>2020-04-04T15:35:23.552Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="第一章-进程与线程"><a href="#第一章-进程与线程" class="headerlink" title="第一章 进程与线程"></a>第一章 进程与线程</h1><h2 id="1-1-进程的概念"><a href="#1-1-进程的概念" class="headerlink" title="1.1 进程的概念"></a>1.1 进程的概念</h2><p><strong>进程就是应用程序在内存中分配的空间，也就是正在运行的程序</strong>，各个进程之间互不干扰。同时进程保存着程序每一时刻运行的状态</p><blockquote><p>程序：用某种编程语言（java、python等）编写，能够完成一定任务或者功能的代码集合，是指令和数据的有序集合，是一段静态代码。  </p></blockquote><p><strong>CPU采用时间片轮转的方式运行进程：</strong> CPU为每个进程分配⼀个时间段，称 作它的时间⽚。如果在时间⽚结束时进程还在运⾏，则暂停这个进程的运⾏，并且<br>CPU分配给另⼀个进程（这个过程叫做<strong>上下⽂切换</strong>）。如果进程在时间⽚结束前阻 塞或结束，则CPU⽴即进⾏切换，不⽤等待时间⽚⽤完。  </p><p><strong>进程让操作系统的并发成为了可能</strong>。虽然并发从宏观上看有多个 任务在执⾏，但在事实上，对于单核CPU来说，任意具体时刻都只有⼀个任务在占 ⽤CPU资源。</p><h3 id="1-1-1-线程的概念"><a href="#1-1-1-线程的概念" class="headerlink" title="1.1.1 线程的概念"></a>1.1.1 线程的概念</h3><p><strong>让一个线程执行一个子任务，这样一个进程就包含了多个线程，每个线程负责一个单独的子任务。</strong></p><p>进程让操作系统的并发性成为了可能，⽽<strong>线程让进程的内部并发成为了可能</strong>。</p><h3 id="1-1-2-多线程的好处："><a href="#1-1-2-多线程的好处：" class="headerlink" title="1.1.2 多线程的好处："></a>1.1.2 多线程的好处：</h3><ul><li><p>进程间的通信⽐较复杂，⽽线程间的通信⽐较简单，通常情况下，我们需要使 ⽤<strong>共享资源</strong>，这些资源<strong>在线程间的通信⽐较容易。</strong></p></li><li><p>进程是重量级的，⽽线程是轻量级的，故多线程⽅式的<strong>系统开销更⼩。</strong></p></li></ul><h3 id="1-1-3-进程和线程的区别："><a href="#1-1-3-进程和线程的区别：" class="headerlink" title="1.1.3 进程和线程的区别："></a>1.1.3 进程和线程的区别：</h3><p>他们两个的本质区别是<strong>是否单独占有内存地址空间及其它系统资源（⽐如I/O）</strong>：</p><ul><li><p>进程单独占有⼀定的内存地址空间，⽽线程共享所属进程占有的内存地址空间和资源</p></li><li><p>进程间存在内存隔离，数据是分开的，数据共享复杂但是同步简单；⽽线程数据共享简单，但是同步复杂。</p></li><li><p>⼀个进程出现问题不会影响其他进程，不影响主程序的稳定性，可靠性⾼；⼀个线程崩溃可能影响整个程序的稳定性，可靠性较低。 </p></li><li><p>进程的创建和销毁不仅需要保存寄存器和栈信息，还需要资源的分配回收以及⻚调度，开销较⼤；线程只需要保存寄存器和栈信息，开销较⼩。</p></li></ul><p>另外⼀个重要区别是，<strong>进程是操作系统进⾏资源分配的基本单位，⽽线程是操作系 统进⾏调度的基本单位，即CPU分配时间的单位。</strong></p><h2 id="1-2-上下文切换"><a href="#1-2-上下文切换" class="headerlink" title="1.2 上下文切换"></a>1.2 上下文切换</h2><p>上下文切换（进程切换或者任务切换）是指CPU从一个进程（或线程）切换到另一个进程（或线程）。上下文是指<strong>某一时间点CPU寄存器和程序计数器的内容</strong></p><p><strong>CPU通过为每个线程分配CPU时间⽚来实现多线程机制</strong>。CPU通过时间⽚分配算法来循环执⾏任务，当前任务执⾏⼀个时间⽚后会切换到下⼀个任务。</p><p>但是，在切换前会保存上⼀个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以<strong>任务从保存到再加载的过程就是⼀次上下⽂切换</strong>。</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;第一章-进程与线程&quot;&gt;&lt;a href=&quot;#第一章-进程与线程&quot; class=&quot;headerlink&quot; title=&quot;第一章 进程与线程&quot;&gt;&lt;/a&gt;第一章 进程与线程&lt;/h1&gt;&lt;h2 id=&quot;1-1-进程的概念&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="java基础" scheme="https://qihuang7.top/categories/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="https://qihuang7.top/categories/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://qihuang7.top/tags/java/"/>
    
      <category term="基础" scheme="https://qihuang7.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="https://qihuang7.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="https://qihuang7.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>算法基础--排序：选择排序与插入排序</title>
    <link href="https://qihuang7.top/2020/04/02/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80--%E6%8E%92%E5%BA%8F%EF%BC%9A%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%89/"/>
    <id>https://qihuang7.top/2020/04/02/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80--%E6%8E%92%E5%BA%8F%EF%BC%9A%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%89/</id>
    <published>2020-04-01T17:06:31.000Z</published>
    <updated>2020-04-04T15:35:50.120Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="排序算法类模板"><a href="#排序算法类模板" class="headerlink" title="排序算法类模板"></a>排序算法类模板</h1><p>约定：我们会将排序代码放在类中的sort()方法中，该类还将包含辅助函数less()和exch()以及一个测试用例main()。</p><p>less()方法对元素进行比较，exch()方法将元素交换位置。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排序算法的具体操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>{</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断两个元素哪个更小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) < <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将元素交换位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{</span><br><span class="line">        Comparable t = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable[] a)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < a.length; i++) {</span><br><span class="line">            System.out.println(a[i] + <span class="string">" "</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试数组是否有序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(Comparable[] a)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i < a.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (less(a[i], a[i - <span class="number">1</span>])) {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        String[] a = {<span class="string">"S"</span>,<span class="string">"O"</span>,<span class="string">"R"</span>,<span class="string">"T"</span>,<span class="string">"E"</span>,<span class="string">"X"</span>,<span class="string">"A"</span>,<span class="string">"M"</span>,<span class="string">"P"</span>,<span class="string">"L"</span>,<span class="string">"E"</span>};</span><br><span class="line">        sort(a);</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a)</span></span>;</span><br><span class="line">        show(a);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这个类展示的是数组排序实现的框架。对于我们学习的每种排序算法，我们都会为这样一个类实现一个sort()方法并将Example改为算法的名称。</p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p><strong>最简单的排序算法（选择排序）：不断地选择剩余元素之中的最小者，</strong> 步骤如下：</p><ol><li>找到数组中最小的那个元素</li><li>将它和数组中的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）</li><li>在剩下的元素中找到最小的元素，将他和第二个元素交换位置</li><li>如此往复，直到将整个数组排序</li></ol><p>选择排序的内循环只是在比较当前元素与目前已知的最小元素（以及将当前索引加1和检查代码是否越界）。交换元素的代码写在内循环之外，每次交换都能排定一个元素，因此交换的总次数是N。所以算法的时间效率取决于比较的次数（交换次数和数组的大小式成线性关系）</p><p>选择排序有两个鲜明的特点：运行时间和输入无关；数据移动式最少的。</p><h2 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h2><p><a href="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/algorithm/sort/selectionSort.gif" data-fancybox="group" data-caption="选择排序" class="fancybox"><img alt="选择排序" title="选择排序" data-src="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/algorithm/sort/selectionSort.gif" class="lazyload"></a></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Selection</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        <span class="comment">//将a[i]和a[i+1...N]中最小的元素交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < N; i++) {</span><br><span class="line">            <span class="comment">//最小元素的索引</span></span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j < N; j++) {</span><br><span class="line">                <span class="keyword">if</span> (less(a[j], a[min])) {</span><br><span class="line">                    min = j;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            exch(a, i, min);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//less()、exch()、isSorted()和main()方法见“排序算法模板”</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>时间复杂度：O(N^2)</strong></p><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p><strong>为了给要插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位，这种算法叫做插入排序。</strong></p><p>与选择排序一样，当前索引左边的所有元素都是有序的，但它们的最终位置还不确定，为了给更小的元素腾出空间，它们可能会被移动。但是<strong>当索引到达数组的右端时，数组排序就完成了。</strong><br>和选择排序不同的时，<strong>插入排序所需的时间取决于输入中元素的初始顺序。</strong>例如，对一个很大且其中的元素已经有序（或者接近有序）的数组进行排序将会比对随机顺序的数组或是逆序数组排序要快得多。</p><p>插入排序对实际应用中常见的某些类型<strong>的非随机数组很有效</strong>。它的运行时间也是线性的</p><h2 id="动图演示-1"><a href="#动图演示-1" class="headerlink" title="动图演示"></a>动图演示</h2><p><a href="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/algorithm/sort/insertionSort.gif" data-fancybox="group" data-caption="插入排序" class="fancybox"><img alt="插入排序" title="插入排序" data-src="https://myblog-file.oss-cn-shenzhen.aliyuncs.com/algorithm/sort/insertionSort.gif" class="lazyload"></a></p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insertion</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i < N; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j > <span class="number">0</span> && less(a[j],a[j-<span class="number">1</span>]); j--) {</span><br><span class="line">                exch(a,j,j-<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//less()、exch()、isSorted()和main()方法见“排序算法模板”</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>时间复杂度：O(n^2)</strong></p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;排序算法类模板&quot;&gt;&lt;a href=&quot;#排序算法类模板&quot; class=&quot;headerlink&quot; title=&quot;排序算法类模板&quot;&gt;&lt;/a&gt;排序算法类模板&lt;/h1&gt;&lt;p&gt;约定：我们会将排序代码放在类中的sort()方法中
      
    
    </summary>
    
    
      <category term="算法" scheme="https://qihuang7.top/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="https://qihuang7.top/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="排序" scheme="https://qihuang7.top/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="基础" scheme="https://qihuang7.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="算法" scheme="https://qihuang7.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://qihuang7.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>每日一题：两数之和</title>
    <link href="https://qihuang7.top/2020/04/01/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>https://qihuang7.top/2020/04/01/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%9A%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2020-04-01T15:18:56.000Z</published>
    <updated>2020-04-04T16:51:36.103Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h1><p><strong>难度：简单</strong></p><p><strong>题目：</strong> 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p><strong>示例：</strong></p><blockquote><p>给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]  </p></blockquote><p><strong>我的解法：暴力解法</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < nums.length; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j < nums.length; j++) {</span><br><span class="line">                <span class="keyword">if</span> (nums[j] == target - nums[i]) {</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] { i, j };</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>执行结果：</strong> 通过<br><strong>执行用时 :</strong> 188 ms<br><strong>内存消耗 :</strong> 40 MB  </p><p><strong>官方题解：两遍哈希表</strong>  </p><p>为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。</p><p>通过<strong>以空间换取速度</strong>的方式，我们可以将查找时间从 O(n) 降低到 O(1)。哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)。</p><p>一个简单的实现使用了两次迭代。<strong>在第一次迭代中，我们将每个元素的值和它的索引添加到表中。</strong> <strong>然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target−nums[i]target - nums[i]target−nums[i]）是否存在于表中。</strong> 注意，该目标元素不能是 nums[i]nums[i]nums[i] 本身！</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) {</span><br><span class="line">        Map<integer, integer> map = <span class="keyword">new</span> HashMap<>();</integer,></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < nums.length; i++) {</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < nums.length; i++) {</span><br><span class="line">            <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(complement) && map.get(complement) != i) {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] { i, map.get(complement) };</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>复杂度分析：</strong></p><p><strong>时间复杂度：O(n)，</strong><br>我们把包含有 nnn 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1) ，所以时间复杂度为 O(n)。</p><p><strong>空间复杂度：O(n)，</strong><br>所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 n 个元素</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;1-两数之和&quot;&gt;&lt;a href=&quot;#1-两数之和&quot; class=&quot;headerlink&quot; title=&quot;1.两数之和&quot;&gt;&lt;/a&gt;1.两数之和&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;难度：简单&lt;/strong&gt;&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://qihuang7.top/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://qihuang7.top/tags/leetcode/"/>
    
      <category term="数组" scheme="https://qihuang7.top/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
</feed>
